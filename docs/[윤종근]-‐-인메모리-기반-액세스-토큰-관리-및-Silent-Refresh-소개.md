# 📖 인메모리 기반 액세스 토큰 관리 및 Silent Refresh 소개

## ✨ 한 줄 요약
> 보안 강화를 위해 Access Token을 변수(인메모리)에 저장하여 XSS 공격을 차단하고 Silent Refresh 로직을 구현하여 새로고침 시에도 사용자 세션이 끊기지 않도록 구현

## 🎯 등장 배경
- 왜 이 개념/도구가 등장했는가? 브라우저 환경에서 액세스 토큰을 안전하게 관리하고 페이지 새로고침이나 만료 시에도 UX를 유지하기 위해 도입됐다.
- 해결하고자 하는 문제:
  - XSS 공격(공격자의 악성 스크립트 삽입)으로부터 장기 저장소(localStorage/sessionStorage)에 보관된 토큰이 탈취되는 위험
  - 페이지 새로고침 시 클라이언트 메모리의 토큰이 사라져 자동 로그아웃되는 UX 문제
  - 동시에 여러 요청에서 토큰 리프레시가 중복 호출되어 race condition이 발생하는 문제

## 🔑 핵심 개념
- 인메모리 토큰 저장: `tokenStore` 모듈에 모듈 스코프 변수로 액세스 토큰을 보관하고 import로 사용하여 XSS로부터 보호
- Refresh Token(서버 저장, httpOnly 쿠키): 민감한 리프레시 토큰은 httpOnly 쿠키로 서버에서 관리하고 클라이언튼느 리프레시 엔드포인트 호출로 새로운 액세스 토큰을 발급받음
- Silent Refresh (앱 초기화 및 요청 실패 시 자동 갱신): 앱 초기화 시 Auth 정보가 필요하면 토큰을 리프레시하고 fetch Wrapper는 401 응답을 받으면 백그라운드에서 리프레시를 수행한 뒤 API 요청을 재시도 함

## ⚙️ 동작 방식
1. 로그인 성공
  - 서버로부터 받은 액세스 토큰은 인메모리로 저장: 액세스 토큰 setter 함수 및 전역 Auth 상태를 통해 리액트 상태를 갱신하여 UI 반영
  - 클라이언트는 UX 편의를 위해 로그인 여부만 localStorage에 남겨 리프레시를 해야할 지 판단
2. 앱 초기화 (새로고침 포함)
  - 전역 Auth Provider가 로그인 정보 요청 함수를 호출하고 내부에서 인메모리 토큰을 확인 -> 인메모리 토큰이 없고 localStorage에 로그인 여부가 있다면 refresh를 호출하여 인메모리 토큰을 복구
3. 요청 중 토큰 만료 대응
  - fetch Wrapper의 `request` 함수는 `getAccessToken()` 함수를 통해 헤더를 설정하고 응답이 401(액세스 토큰 만료)이면 `refreshAccessToken()`을 통해 백그라운드 리프레시를 수행하고 리프레시 성공 시 401 응답을 받은 요청을 재요청한다.
  - `refreshAccessToken()`은 모듈 레벨에서 `refreshPromise`를 사용해 중복 리프레시를 방지하여 race handling을 한다.

## 👍 장점
- 보안: 액세스 토큰을 인메모리에만 보관하므로 XSS 공격으로부터 토큰 탈취 위험이 크게 감소한다.
- UX: Silent Refresh로 새로고침/토큰 만료 시에도 사용자 세션이 유지되어 로그인 UX가 끊기지 않는다.
- 안정성: `refreshPromise` 패턴으로 다중 동시 요청 시 리프레시 중복 호출과 관련된 race condition을 방지한다.

## 👎 단점
- 탭/창 간 공유 불가: 인메모리 토큰은 같은 브라우저의 다른 탭과 공유되지 않으므로 탭 간 연속성을 제공하지 않는다.
- 리프레시 실패 시 복구 복잡성: 리프레시 토큰이 만료되면 localStorage 플래그(expires)와 결합하거나 클라리언트 측에서 임시 쿠키를 생성하여 재인증 흐름(로그인 페이지 이동 등)을 처리해야 한다. (현재 프로젝트에서는 리프레시 토큰 만료에 대한 플래그를 구현하지 않음)

## 🧩 언제 사용하면 좋은가?
- 사용하기 좋은 상황:
  - 실제 서비스 배포 시 XSS 리스크를 줄이면서 세션 유지를 원할 때
  - 보안이 중요한 경우에 권장
- 피해야 할 상황:
  - 다수의 탭 간 토큰 동기화가 핵심 UX인 경우