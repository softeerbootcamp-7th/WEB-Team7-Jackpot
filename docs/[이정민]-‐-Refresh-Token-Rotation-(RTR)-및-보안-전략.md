## 💡 Q. Reissue 시 왜 RefreshToken까지 새로 발급해야 할까?

### 📖 Refresh Token Rotation (RTR)이란?

RT를 한 번 사용하면 폐기하고, 새로운 AT와 함께 **새로운 RT를 발급**해주는 보안 전략. 즉, RT를 '일회용'처럼 사용하는 것.

### 🎯 why?

#### 1) RT가 탈취당했을 때의 피해 최소화

RT는 유효기간이 매우 길다. 만약 해커가 사용자의 RT를 몰래 훔쳤다고 가정한다면,

- **RTR이 없다면:** 해커는 2주 동안 언제든지 그 RT를 사용해 새로운 AT를 받아낼 수 있다. 사용자가 비밀번호를 바꾸기 전까지는 무방비 상태.
- **RTR이 있다면:** 해커가 RT를 사용해 AT를 발급받는 순간, **기존 RT는 무효화되고 새 RT가 발급된다.** 해커가 가진 RT는 이제 '이미 사용된’ 쓸모없는 정보가 된다.

#### 2) 도난 감지 및 자동 차단

만약 해커와 실제 사용자가 **같은 RT를 동시에 가지고 있는 상황**이 발생하면 어떻게 될까?

1. **해커**가 먼저 탈취한 RT로 재발급을 받는다. (서버는 해커에게 새 AT와 새 RT를 준다.)
2. 이후 **실제 사용자**가 자신의 앱에서 재발급을 시도한다. (사용자는 이미 해커가 써버린 '이미 사용된 RT'를 내민다.)
3. **서버의 반응:** "어? 이 RT는 이미 사용된 건데? **누군가 이 토큰을 훔쳤구나!**"라고 판단한다.
4. **조치:** 서버는 즉시 해당 사용자의 **모든 토큰을 만료**시키고 강제 로그아웃 시킨 뒤, 다시 로그인하게 만든다.

reference: https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation

<br>

### Q. RTR 방식이더라도, 해커가 탈취한 리프레시 토큰(RT 1)으로 먼저 액세스 토큰(AT 2)과 새 리프레시 토큰(RT 2)을 받아냈다면, 그 시점부터 유저가 재로그인을 시도할 때까지 해커는 유효한 권한을 가지는 것이 아닌지?

맞음. 정상 유저인지 해커인지 확인할 수 있는 방식이 없지만, 토큰 만료 기간 전까지 내내 사용가능한 것보단 나은 방법이기에 사용되고 있음. 찾아본 결과, 다음과 같은 기술이 있음


기술 | 핵심 아이디어 | 방어 포인트
-- | -- | --
RTR | 토큰을 계속 새로 교체 | 유출 시 피해 기간 단축 & 재사용 감지
DPoP | 토큰에 디지털 서명 추가 | 토큰을 훔쳐가도 다른 기기에서 사용 불가
mTLS | 암호화 통과 경로 제한 | 정해진 통로(인증서)가 아니면 사용 불가
MFA | 2차 인증 (OTP 등) | 토큰이 있어도 본인 인증 없으면 갱신 불가

<br>

### Q. 일반적으로 리프레시 토큰 관리에는 Redis가 사용된다고 한다. 왜 그럴까?
- 만료일을 지정할 수 있다. (TTL) → 토큰이 만료되면 redis에서도 삭제되도록 가능
- 성능 및 부하 분산
- Redis는 싱글 스레드로 동작하므로, RTR 로직에서 "토큰 확인 후 즉시 삭제/갱신"하는 과정에서 발생할 수 있는Race Condition을 원자적으로 처리
- 메모리 기반이므로 서버 재시작 시 데이터가 유실될 수 있다는 점이 단점이나, 유실의 결과는 '사용자의 재로그인'이며, 이는 Critical 하지 않다고 생각한다. 

<br>

### 🎯리프레시 토큰 관리 저장소로 RDBMS 채택

**현황:** 리프레시 토큰 로테이션(RTR) 구현 시 Redis가 권장되나, 사용하지 않기로 함.

1. **인프라 단순화:** 추가적인 인프라(Redis) 구축 없이 기존 DB를 활용하여 개발 생산성 확보.
2. **트래픽 분석:** 현재 서비스 규모에서는 DB 인덱싱만으로도 토큰 검증 성능이 충분하며, I/O 병목이 발생할 단계가 아니라고 판단
3. **데이터 정합성:** 유저 상태 변화(회원 탈퇴, 차단 등)와 토큰 무효화 처리를 하나의 트랜잭션 내에서 원자적으로 관리 가능.
4. **유지보수:** 관리가 필요한 엔티티를 하나로 통합하여 시스템 복잡도 감소.

<br>