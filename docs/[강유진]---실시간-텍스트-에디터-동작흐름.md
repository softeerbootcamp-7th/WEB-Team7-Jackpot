> **이 글은 `contentEditable` 기반 커스텀 에디터가 키보드 입력, 커서 이동, 한글 IME, 소켓 이벤트, 리뷰(댓글) 등 모든 동작을 어떻게 처리하는지 흐름 중심으로 정리한 기술 문서입니다.**

---

## 1. 왜 contentEditable인가 — 아키텍처 선택

저희 서비스의 기획상, 텍스트 에디터에 리뷰가 달리면 style 추가가 필요합니다. 이 스타일이 단순한 하이라이팅이 아닌, 아래 영역의 opacity와 padding 적용이 들어가기 때문에 일반 textarea나 input 태그를 통한 구현은 어렵습니다.

따라서 텍스트 에디터 라이브러리를 사용하거나, 직접 텍스트 에디터 라이브러리를 구현하는 방법이 존재하였습니다. 간단한 스타일링을 위하여 라이브러리를 도입하는 것은 과한 기술 사용이라는 생각이 들었습니다. 따라서 도입 이전에 직접 구현하여 보다 기본 텍스트 에디터의 동작에서 스타일링만 가능한 방식은 없을지를 먼저 찾아보게 되었습니다. 그 과정에서 알게된 것이 contentEditable 속성이었습니다.

해당 속성은 div 태그를 input 태그나 textarea 태그처럼 입력이 가능하도록 만들어주는 속성이었습니다. 따라서 내부에 스타일을 설정한 children 요소들을 넣으면 쉽게 구현이 될 것 같다는 생각을 했습니다. 해당 아이디어를 빠르게 적용하여 탐색을 해본 결과, 아래의 에러를 만날 수 있었습니다. 에러의 내용은 **수정이 가능한 요소 내에 react에서 관리하는 children도 포함되어 있기 때문에 요소의 내용이 예기치 않게 수정되지 않도록 주의해 달라**는 내용입니다. 즉, **요소를 수정함으로써 실제 dom과 react가 예측하는 dom의 내용과 달라지기 때문에, dom의 변경 사항 동기화에 문제가 생길 수도 있어 발생하는 경고**입니다. 해당 경고를 무시하기 위해서는 **suppressContentEditableWarning 속성**을 추가해주면 됩니다. 다만 경고와 같이 브라우저의 조작으로 인해 실제 DOM과 React가 예측하고 있는 DOM의 내용이 달라질 수 있기 때문에 주의가 필요합니다.

<img width="667" height="358" alt="Image" src="https://github.com/user-attachments/assets/27787c65-504e-4787-bdf4-538628bb7253" />
<img width="498" height="256" alt="Image" src="https://github.com/user-attachments/assets/a197a30a-be35-46d6-a901-257fb117785d" />

children 요소를 넣지 않고 contentEditable을 사용하는 방법에는 **dangerouslysetinnerhtml** 속성을 사용하여, **DOM 요소의 HTML 콘텐츠**를 설정하는 방법이 있습니다. 브라우저 DOM에서 **innerHTML**을 사용하기 위한 React의 대체 방법으로, 일반적으로 코드에서 HTML을 설정하는 것은 **사이트 간 스크립팅(XSS) 공격**에 쉽게 노출되기에 위험합니다. 실제로 빠르게 적용해보았을 때, 코드래빗의 XSS 공격에 주의하라는 리뷰를 받을 수 있었습니다.

따라서 저희는 **suppressContentEditableWarning 속성**을 사용하고, 직접 저희가 실제 DOM과 React가 예측 중인 DOM 사이의 간격을 줄이는 방법을 통해 구현을 시작하게 되었습니다.

### 브라우저의 기본 contentEditable 동작

앞서 말씀드린 것 처럼 브라우저는 `contentEditable="true"` 속성을 주면 그 DOM 요소를 즉시 편집 가능 영역으로 만들어 줍니다. 키를 누르면 브라우저가 직접 DOM을 조작해서 텍스트 노드를 추가·제거하고, Backspace면 앞 글자를 지우고, Enter면 `<div>` 또는 `<br>`을 삽입합니다. 커서 위치도 브라우저의 Selection API가 자동으로 관리합니다.

이 방식은 간단해 보이지만, **리뷰(하이라이트 + 댓글) 구조처럼 DOM이 복잡한 경우 브라우저가 예상치 못한 DOM 변형을 일으킵니다.**

### React와의 충돌 — removeChild 에러의 원인

React는 Virtual DOM을 통해 실제 DOM을 관리합니다. 그런데 `contentEditable` 영역 안에서 브라우저가 DOM을 직접 변경하면, 다음 렌더링 시 React가 가진 Virtual DOM 트리와 실제 DOM 트리가 달라집니다. React는 자신이 만든 노드가 있다고 생각하지만, 브라우저가 이미 그 노드를 제거했기 때문에 `removeChild: The node to be removed is not a child of this node` 에러가 발생합니다.

```
React Virtual DOM: [span.chunk][span.chunk][span.review-outer]
실제 DOM (브라우저가 수정 후): [span.chunk][text node][span.review-outer]
→ React가 span.chunk를 removeChild 시도 → 이미 없음 → 에러
```

### 해결책 — "브라우저 기본 동작을 모두 막고, 직접 구현한다"

이 에디터의 핵심 철학은 단순합니다.

> **contentEditable은 커서와 Selection API를 쓰기 위한 껍데기로만 사용하고, 실제 DOM 변형은 React 상태(text state)를 통해서만 한다.**

모든 키보드 이벤트(Backspace, Delete, Enter, 일반 문자)에 `preventDefault()`를 호출해서 브라우저가 DOM을 건드리지 못하게 하고, 대신 `text` state를 업데이트하면 React가 새로운 DOM을 올바르게 렌더링합니다.

---

## 2. DOM 구조 — 청크와 리뷰 렌더링

### 청크(Chunk) 개념

에디터 내부에서 텍스트는 **청크(chunk)** 단위로 분리됩니다. 청크는 두 종류입니다.

- **일반 청크**: 리뷰가 없는 평범한 텍스트 → `<span contentEditable={true}>텍스트</span>`
- **리뷰 청크**: 리뷰가 달린 텍스트 구간 → 중첩 구조 사용

`buildChunks` 함수가 `text` state와 `reviews` 목록을 받아서 이 청크 배열을 만들고, React가 렌더링합니다.

### 리뷰 청크의 중첩 구조

리뷰 영역은 **두 겹의 span**으로 만들어집니다.

```html
<!-- outer: contentEditable=false로 전체 리뷰 영역을 편집 불가 감싸기 -->
<span contentEditable="{false}" class="review-outer">
  <!-- 경계 마커: 리뷰 영역 시작을 알리는 zero-width space -->
  <span data-review-boundary contentEditable="{true}">&#x200B;</span>

  <!-- inner: 실제 편집 가능한 리뷰 텍스트 -->
  <span contentEditable="{true}" class="review-inner">리뷰된 텍스트</span>

  <!-- 꼬리 마커: 리뷰 영역 끝을 알리는 zero-width space -->
  <span data-review-tail contentEditable="{true}">&#x200B;</span>
</span>
```

**왜 outer를 `contentEditable=false`로 하나?**
첨삭 기능을 구현하면서 가장 중요했던 목표는 “첨삭 영역이 일반 텍스트처럼 보이되, 일반 텍스트처럼 동작하지 않게 하는 것”입니다.
즉, 사용자는 첨삭된 문장을 자연스럽게 읽고 커서를 이동할 수 있어야 하지만, 브라우저나 IME(한글 입력기)가 해당 영역을 자유롭게 편집하거나 DOM 구조를 깨뜨리면 안 되는 상태입니다.

1. 브라우저의 자동 DOM 재구조화를 차단하기 위해
   1. contentEditable=true 영역 안에서 브라우저는 다음과 같은 행동을 합니다.
      1. 커서 이동 시 내부 span을 병합하거나 분리
      2. 한글 IME 조합 중 임시 span 삽입
         삭제/입력 시 예측 불가능한 text node 재배치
   2. 특히 첩삭 span이 여러 개 중첩된 상태에서는, 브라우저가 “여기도 editable하네?”라고 판단하는 순간
      리뷰 단위를 유지하지 않고 DOM을 평탄화(flatten) 해버리는 문제가 발생합니다.
   3. outer를 contentEditable=false로 두면 브라우저는 이 영역을 하나의 불변 블록으로 취급합니다
   4. 즉, 브라우저가 내부 구조를 건드리지 않습니다.
   5. 삭제/입력/조합 중에도 wrapper 단위는 유지됩니다
   6. 리뷰 경계가 DOM 차원에서 안정적으로 보존됩니다
2. IME(한글 입력기) 조합 안정성을 확보하기 위해
   1. 한글 IME는 조합 중에 다음과 같은 동작을 합니다
      1. 조합 상태를 임시 span으로 감쌉니다
      2. 조합이 끝나면 해당 span을 제거하고 실제 텍스트를 삽입합니다
   2. 문제는, 이 과정이 contentEditable=true 영역 내부라면 어디든지 발생한다는 점입니다
   3. 리뷰 outer를 contentEditable=false로 두면
      1. IME 조합 span이 리뷰 outer를 침범하지 않습니다
      2. 조합 텍스트가 리뷰 내부로 “붙어버리는” 현상을 막을 수 있습니다
      3. 조합 종료 후 DOM과 React 상태 불일치 문제를 줄일 수 있습니다
   4. 즉, 이 구조는 한글 입력 안정성을 위한 방어막 역할도 수행합니다

**왜 `\u200B`(zero-width space) 마커를 쓰나?**
contentEditable 기반 에디터에서 가장 까다로운 문제 중 하나는 커서(caret)와 줄바꿈, 그리고 IME(한글 조합) 동작을 예측 가능하게 만드는 것이피다. 특히 리뷰(첨삭)처럼 contentEditable=false 영역과 일반 텍스트가 섞여 있는 구조에서는, 브라우저의 기본 커서 이동 규칙이 쉽게 깨집니다.
이 문제를 해결하기 위해 저는 \u200B(Zero-Width Space, ZWSP) 를 “보이지 않는 구조적 마커”로 사용했습니다.

1. 브라우저는 “빈 경계”에 커서를 안정적으로 두지 못합니다
   1. 브라우저는 커서를 텍스트 노드 내부에 두는 것은 잘하지만, 다음과 같은 위치에서는 매우 불안정한 동작을 보입니다
      1. 텍스트 노드의 끝
      2. contentEditable=false 요소의 앞/뒤 경계
      3. <span> 사이에 실제 텍스트 노드가 없는 경우
      4. 줄 끝(\n) 바로 뒤
   2. 이런 위치에서는 커서가
      1. 갑자기 앞 텍스트로 튀거나
      2. contentEditable=false 내부로 빨려 들어가거나
      3. 아예 비활성화된 것처럼 보이는 상태가 됩니다
   3. 즉, “커서를 둘 물리적인 텍스트 노드가 없는 경계”는 위험 지대입니다
   4. \u200B는 이 문제를 해결합니다. 보이지 않지만 실제로는 텍스트 노드 하나를 강제로 만들어 커서가 안착할 수 있는 발판을 제공합니다.

**마지막 청크가 리뷰일 때 빈 span 추가**
리뷰 청크가 맨 끝에 있으면 그 뒤에 커서를 놓을 공간이 없습니다. 빈 `<span contentEditable={true}></span>`을 하나 더 붙여서 사용자가 리뷰 뒤에 새 텍스트를 입력할 수 있게 합니다.

---

## 3. 일반 텍스트 입력 흐름

### 브라우저의 기본 동작

브라우저는 `input` 이벤트나 `keypress` 이벤트를 받으면 커서 위치에 텍스트 노드를 직접 삽입합니다.

### 이 에디터의 처리 방식

```
사용자가 키 입력
→ onKeyDown: 일반 문자는 preventDefault 하지 않음
→ onInput 이벤트 발생
   → IME 조합 중이면 handleCompositionUpdate로 처리
   → 일반 입력이면:
      1. getCaretPosition()으로 현재 커서 위치(clean text 기준 index) 획득
      2. 브라우저가 이미 DOM에 문자를 넣었으므로, collectText()로 현재 DOM의 전체 텍스트 수집
      3. 이전 text state와 새 DOM 텍스트를 비교해 변경 범위 파악
      4. setText()로 React state 업데이트
      5. sendTextPatch()로 소켓 전송 (디바운스)
→ React 리렌더링
→ useLayoutEffect: restoreCaret()으로 커서를 올바른 위치에 복원
```

> **핵심 포인트**: 일반 문자 입력은 `preventDefault`를 하지 않습니다. 브라우저가 DOM을 먼저 바꾸도록 허용한 뒤, 그 결과를 읽어서 React state에 반영합니다. 리렌더링 후 커서를 수동으로 복원합니다.

### collectText와 \u200B 필터링

`collectText()`는 DOM을 순회하면서 텍스트를 수집할 때, `\u200B` 문자를 제거합니다. 이 문자는 리뷰 경계 마커용이므로 실제 텍스트 내용에 포함되면 안 됩니다. 사용자가 입력한 내용이나 서버로 전송하는 텍스트에 `\u200B`가 섞이면 인덱스 계산이 전부 틀어집니다.

---

## 4. 한글(IME) 입력 흐름

### IME란?

IME(Input Method Editor)는 한글, 중국어, 일본어처럼 여러 키 입력을 조합해서 하나의 글자를 만드는 입력기입니다. 브라우저는 조합 중인 글자와 완성된 글자를 구분하기 위해 `compositionstart` → `compositionupdate` → `compositionend` 이벤트를 순서대로 발생시킵니다.

### 브라우저의 기본 동작

조합 중에는 브라우저가 텍스트 노드에 임시 조합 문자를 넣고, `compositionend`에 최종 문자를 확정합니다. React가 이 중간 상태를 제대로 추적하지 못해 상태 불일치가 생길 수 있습니다.

### 이 에디터의 IME 처리 흐름

```
**compositionStart 이벤트**
→ 조합 중복 시작 방지
이미 isComposingRef.current === true면 early return
→ 드래그 선택 상태 정리
드래그 선택 상태에서 IME가 시작되면, 브라우저가 contenteditable=false 영역을 포함한 선택 범위를 DOM에서 직접 삭제하는 문제가 발생함
이 변경은 React가 인지하지 못해 이후 reconcile 과정에서removeChild 오류를 유발할 수 있음
→ 선택 영역이 있는 경우, flushSync로 즉시 삭제
getCaretPosition으로 선택 범위 계산
flushSync(() => applyDeleteRange(start, end)) 실행
이 시점에 React state, 실제 DOM, useLayoutEffect 기반 caret 복원 이 모두가 완전히 동기화된 상태가 됨
→ 조합 시작 전에 React와 DOM의 기준점을 일치시킴
이후 브라우저 IME는 정리된 DOM을 기준으로 조합을 시작
→ 조합 상태 플래그 설정
선택 영역 정리 이후 isComposingRef.current = true
→ 리뷰 경계 캐럿 사전 보정
normalizeCaretAtReviewBoundary() 호출
조합 시작 시 캐럿이 리뷰 경계에 걸린 상태를 방지하기 위함

**compositionUpdate 이벤트**
→ 별도의 처리 없음
이 구현에서는 compositionupdate 이벤트를 직접 다루지 않음
조합 중 DOM 변경은 전적으로 브라우저 IME에 위임
React state는 조합 중에는 갱신하지 않음

**input 이벤트 (조합 중)**
→ 조합 중 입력은 React 처리에서 차단
nativeEvent.isComposing 또는 isComposingRef.current가 true면, processInput 호출을 막음
DOM을 읽거나 state를 갱신하지 않음
→ 조합 중 DOM 상태는 ref로만 추
적collectText(contentRef.current)로 현재 DOM 텍스트를 읽어 composingDOMTextRef에 저장
caret 위치는 composingDOMCaretRef에 저장
목적:조합 중 TEXT_REPLACE_ALL이 발생해 DOM이 덮어써질 경우, 조합 중이던 텍스트를 이후에 재적용하기 위함
→ 이 과정에서도 React state는 변경하지 않음

**compositionEnd 이벤트**
→ 조합 종료 여부 확인
isComposingRef.current === false면 무시
→ 조합 상태 종료
isComposingRef.current = false
→ 조합 종료 시각 기록
lastCompositionEndAtRef.current = Date.now()
이후 keydown(Enter, Backspace 등)에서 조합 직후 에코 이벤트를 구분하는 기준으로 사용
→ 조합 결과를 최종 입력으로 확정
processInput(true) 호출
forceSync = true로 전달하여, DOM 기준 최종 텍스트를 읽고, 부모 state(onTextChange)와 즉시 동기화, 조합 결과를 하나의 입력으로 확정

compositionEnd 이후 Enter 처리 (보조 로직)
→ 조합 중 Enter가 눌린 경우
enterDuringCompositionRef.current === true 이면, 플래그 초기화
normalizeCaretAtReviewBoundary() 호출
줄바꿈('\n')을 명시적으로 삽입
requestAnimationFrame 2단계로 caret 복원
→ 조합 종료 직후 브라우저가 DOM을 재조정하는 타이밍에도 caret 위치가 안정적으로 유지되도록 보장
```

### flushSync가 필요한 이유

flushSync는 React의 상태 업데이트를 즉시 처리하도록 강제하는 API입니다.
일반적으로 React의 업데이트는 비동기로 배치되기 때문에, 업데이트 직후에도 실제 DOM은 이전 상태일 수 있습니다. flushSync로 감싼 업데이트는 그 즉시 렌더링과 DOM 반영, layout effect까지 모두 완료되어 React와 실제 DOM의 상태가 완전히 일치하게 됩니다.
이 코드에서 flushSync가 필요했던 시점은 IME 조합 입력이 시작되는 순간입니다. 드래그로 선택된 상태에서 한글 입력이 시작되면, 브라우저는 React를 거치지 않고 선택 영역을 DOM에서 직접 삭제합니다. 이때 React가 그 사실을 모르고 있으면, 이후 reconcile 과정에서 이미 사라진 노드를 기준으로 업데이트를 시도해 오류가 발생했습니다.
그래서 compositionStart 시점에 flushSync를 사용해 선택 영역 삭제를 React 기준으로 먼저 확정합니다. 이렇게 조합 시작 전에 React state와 실제 DOM의 기준을 맞춰두면, 이후 브라우저가 DOM을 수정하더라도 React와의 불일치나 캐럿 깨짐 같은 문제가 발생하지 않습니다.

### Chrome의 특이한 input 이벤트 순서

표준 순서는 `compositionStart` → `input` → `compositionUpdate`이지만, Chrome은 경우에 따라 `input`이 `compositionStart`보다 먼저 발생합니다. `isComposing` 플래그로 이 경우를 감지해서 일반 input 처리 경로를 타지 않도록 막습니다.

### 조합 중 Enter를 눌렀을 때

`keydown`에서 Enter를 감지하는데, 현재 `isComposing = true`이면 Enter 입력을 즉시 처리하면 안 됩니다(조합 확정 Enter와 줄바꿈 Enter가 뒤섞임). `enterDuringCompositionRef = true`로 플래그만 세워두고, `compositionEnd` 이후에 줄바꿈을 처리합니다.

### lastCompositionEndAtRef의 타이밍 가드

`compositionEnd` 직후에 발생하는 `keydown`(Enter, Backspace)을 무시하기 위해 마지막 `compositionEnd` 시각을 기록합니다. 30ms 이내 Enter, 120ms 이내 Backspace는 "조합 완료 직후 자동 발생한 이벤트"로 간주하고 무시합니다. 이 처리가 없으면 한글 입력 후 Enter 키가 줄바꿈을 두 번 실행하거나, 입력된 글자가 즉시 지워지는 현상이 발생합니다.

### TEXT_REPLACE_ALL 중 조합 중이면?

서버에서 `TEXT_REPLACE_ALL` 이벤트가 오면 전체 텍스트를 서버 기준으로 교체해야 하는데, 지금 한글 조합 중이라면 브라우저가 IME 상태를 유지하고 있어 DOM을 교체하면 조합이 깨집니다. 그래서 `isProcessingReplaceAll` 상태로 표시하고, 조합이 끝난 뒤(`compositionEnd`) `composingDOMTextRef`에 저장된 정보로 재처리합니다.

---

## 5. 삭제(Backspace / Delete) 흐름

### 브라우저의 기본 동작

브라우저는 Backspace 키를 받으면 커서 앞 글자를 DOM에서 직접 제거합니다. 리뷰 구조처럼 복잡한 DOM에서는 브라우저가 노드 경계를 넘나들며 잘못된 노드를 제거할 수 있어, React의 removeChild 에러로 이어집니다.

### 이 에디터의 처리 방식

`handleKeyDown`에서 Backspace/Delete를 감지하면 즉시 `preventDefault()`를 호출합니다. 브라우저가 DOM을 건드리지 못하게 한 뒤 직접 처리합니다.

```
Backspace / Delete 키 입력
→ preventDefault() — 브라우저 DOM 조작 차단
→ getCaretPosition()으로 현재 커서/선택 범위 파악
→ 선택 범위가 있으면 applyDeleteRange() 호출
   → 선택 구간 내 텍스트 제거
   → 걸쳐있는 리뷰 처리 (normalizeReviewsForMapping으로 리뷰 경계 정규화)
→ 선택 없으면 applyDeleteByDirection() 호출
   → Backspace: 커서 앞 1글자 제거
   → Delete: 커서 뒤 1글자 제거
→ 리뷰가 삭제 범위에 걸리면 해당 리뷰 ID를 pendingDeletedReviewIds에 추가
→ setText()로 state 업데이트
→ forceSocket: true로 소켓 즉시 전송 (디바운스 없이)
→ React 리렌더링 + restoreCaret()
```

**왜 삭제는 forceSocket: true인가?**
입력(추가)과 달리 삭제는 즉각성이 중요합니다. 여러 글자를 빠르게 지울 때 디바운스가 걸리면, 서버가 아직 반영하지 않은 상태에서 다음 삭제 이벤트가 오면 OT(Operational Transformation) 계산이 꼬입니다. 삭제는 항상 즉시 전송해서 서버 상태를 실시간으로 동기화합니다.

**normalizeReviewsForMapping이 필요한 이유**
삭제 범위가 리뷰 태그 경계에 걸쳐있을 때, `⟦r:id⟧` 같은 태그 토큰의 일부만 삭제하면 서버의 tagged text 구조가 깨집니다. 이 함수는 삭제 범위가 태그 토큰 내부를 부분 삭제하지 않도록 경계를 바깥으로 확장해서 태그 전체를 포함시킵니다.

---

## 6. Enter 처리 흐름

### 브라우저의 기본 동작

브라우저는 Enter를 누르면 `<div>` 또는 `<br>` 요소를 DOM에 삽입해서 줄바꿈을 표현합니다.

### 이 에디터의 처리 방식

Enter도 `preventDefault()`로 차단합니다. 이 에디터에서 "줄바꿈"은 단순히 `\n` 문자를 `text` state에 삽입하는 것입니다.

```
Enter 키 입력 (IME 조합 중이 아닐 때)
→ preventDefault()
→ getCaretPosition()으로 커서 위치 파악
→ text.slice(0, caretIndex) + '\n' + text.slice(caretIndex) 로 새 text 생성
→ setText()
→ sendTextPatch()
→ restoreCaret()으로 \n 다음 위치에 커서 배치
```

---

## 7. 커서(Caret) 이동 흐름

### 브라우저의 기본 동작

방향키, 마우스 클릭으로 커서를 이동할 때 브라우저가 Selection API를 통해 커서 위치를 자동으로 변경합니다. 이 에디터는 이 동작을 **막지 않습니다.**

### selectionchange 이벤트 처리

커서가 이동하면 `selectionchange` 이벤트가 발생합니다.

```
selectionchange 이벤트
→ isProcessingReplaceAll이 true이면 무시 (TEXT_REPLACE_ALL 처리 중)
→ 현재 Selection에서 anchorNode, anchorOffset 파악
→ normalizeCaretAtReviewBoundary() 호출
   → 커서가 \u200B 경계 마커 위에 있으면 적절한 위치로 이동
   → 커서가 review-outer의 contentEditable=false 영역에 들어갔으면
     moveCaretIntoAdjacentReview()로 리뷰 inner로 진입
→ 현재 커서 위치를 caretIndexRef에 저장
```

### normalizeCaretAtReviewBoundary가 필요한 이유

방향키로 커서를 이동할 때 `contentEditable=false`인 outer span 위에 커서가 착지하는 경우가 있습니다. 이 상태에서는 텍스트 입력이 불가능합니다. 이 함수는 그 상황을 감지하고 커서를 리뷰 inner span의 올바른 위치로 옮깁니다.

**moveCaretIntoAdjacentReview에서 offset=1을 주는 이유**
offset=0으로 설정하면 커서가 `\u200B` 경계 마커 앞에 위치해서, 다음 입력 시 마커와 실제 텍스트 사이에 내용이 삽입되는 문제가 발생합니다. offset=1은 마커를 건너뛰어 실제 텍스트 시작 위치를 의미합니다.

### restoreCaret — 렌더링 후 커서 복원

React가 리렌더링하면 DOM이 새로 생성됩니다. 이때 커서 위치가 초기화됩니다. `restoreCaret(targetIndex)`는 `targetIndex`(clean text 기준 인덱스)를 받아서, 새로운 DOM에서 그에 해당하는 노드와 offset을 찾아 `range.setStart(node, offset)`으로 커서를 복원합니다.

**왜 useLayoutEffect인가?**`useEffect`는 브라우저가 화면을 그린 뒤에 실행됩니다. 화면을 그리기 전에 커서를 복원하지 않으면, 잠깐 커서가 사라졌다가 다시 나타나는 깜박임이 생깁니다. `useLayoutEffect`는 DOM 변경 후, 브라우저 페인트 전에 실행되므로 깜박임 없이 커서를 복원할 수 있습니다.

### getCaretPosition — 커서 위치를 인덱스로 변환

`getCaretPosition()`은 현재 Selection의 `range.cloneContents()`로 커서 앞까지의 내용을 복제한 뒤, 그 텍스트 길이를 계산해서 clean text 기준 인덱스를 반환합니다.

단순히 TreeWalker로 각 텍스트 노드의 offset을 누적하는 방식 대비 `cloneContents()`가 좋은 이유는, range가 중간에 `contentEditable=false` 노드를 가로지르거나 `\u200B` 마커가 포함될 때 정확한 텍스트 길이를 계산하기 어렵지 않기 때문입니다. cloneContents는 해당 구간의 실제 콘텐츠를 그대로 복사해오므로 복잡한 구조에서도 신뢰도가 높습니다.

---

## 8. 드래그 선택 후 입력/삭제 흐름

### 처리가 두 군데 있는 이유

드래그로 텍스트를 선택하고 새 글자를 입력하면 선택 구간이 먼저 삭제되고 새 글자가 입력됩니다. 이 동작은 두 경로에서 처리됩니다.

1. **일반 키 입력(`handleKeyDown`)**: 선택 범위가 있으면 입력 전에 선택 범위를 삭제 처리
2. **IME 시작(`handleCompositionStart`)**: 한글 조합 시작 시 선택 범위가 있으면 `flushSync`로 즉시 삭제 처리

두 경로를 분리한 이유는 IME에서는 `compositionStart` 시점에 선택 삭제를 완료하지 않으면, 조합이 시작되면서 브라우저가 선택 범위에 임시 조합 텍스트를 삽입하는 위치가 불명확해지기 때문입니다.

---

## 9. 복사/붙여넣기 흐름

### 복사

```
copy 이벤트
→ 현재 선택 범위의 텍스트를 collectText()로 수집
→ \u200B 제거
→ clipboardData.setData('text/plain', cleanText)
→ preventDefault() — 브라우저가 \u200B 포함 원본을 복사하는 것 차단
```

`\u200B`를 제거하지 않으면 클립보드에 보이지 않는 문자가 포함됩니다. 다른 앱에 붙여넣을 때 예상치 못한 공백이나 글자가 삽입될 수 있습니다.

### 붙여넣기

```
paste 이벤트
→ preventDefault() — 브라우저의 서식 있는 텍스트 붙여넣기 차단
→ clipboardData.getData('text/plain')으로 순수 텍스트만 추출
→ 현재 선택 범위가 있으면 먼저 삭제
→ getCaretPosition()으로 커서 위치 파악
→ 붙여넣기 텍스트 삽입 → setText()
→ sendTextPatch() 즉시 전송
→ restoreCaret()
```

브라우저의 기본 붙여넣기를 허용하면 서식(볼드, 색상 등)이 그대로 들어오거나 HTML 태그가 DOM에 삽입됩니다. 이 에디터는 순수 텍스트만 다루므로 항상 `text/plain`으로만 처리합니다.

---

## +) useLayoutEffect

### caret 복원과 DOM 정리를 위한 useLayoutEffect

이 컴포넌트는 contentEditable 기반 편집기라서, React 렌더링 이후에도 브라우저가 자동으로 text node를 삽입하거나 DOM 구조를 변형하는 문제가 있습니다. 특히 텍스트 변경, 리뷰 chunk 재빌드, undo/redo 이후에는 React가 만든 DOM과 브라우저가 만든 DOM이 섞이게 되는데, 이 상태에서 caret 위치를 계산하면 기준이 흔들립니다.

그래서 이 useLayoutEffect에서는 React 커밋 직후, 브라우저가 화면을 그리기 전에 불필요한 text node를 제거하고 data-chunk 기준으로 DOM 구조를 정리한 뒤, 내부에서 관리하던 caretOffsetRef를 기준으로 커서를 복원합니다. 이 작업이 useEffect에서 실행되면, 이미 잘못된 caret 위치가 한 프레임 동안 화면에 노출됐다가 다시 이동하게 되어 깜빡임이나 selection race condition이 발생할 수 있습니다.

즉, 이 코드는 “렌더 결과를 관찰”하는 effect가 아니라, 렌더 결과를 보정해서 최종 레이아웃을 완성하는 단계이기 때문에 useLayoutEffect를 사용해야 했습니다.

### TEXT_REPLACE_ALL + IME 조합 복구를 위한 useLayoutEffect

두 번째 useLayoutEffect는 서버에서 TEXT_REPLACE_ALL 이벤트가 들어왔을 때, 특히 한글 IME 조합 중 발생하는 엣지 케이스를 처리하기 위한 코드입니다. 조합 중에 외부 텍스트 동기화가 발생하면 React가 새로운 text로 DOM을 덮어쓰면서, 아직 확정되지 않은 조합 문자가 그대로 사라지는 문제가 있습니다.

이 effect에서는 React가 DOM을 커밋한 즉시 시점에, input 이벤트에서 미리 저장해 둔 조합 중 DOM 텍스트와 caret 위치를 ref에서 꺼내 복구하고, 필요하면 강제로 다시 updateText를 호출해 상태·서버·DOM을 다시 일치시킵니다. 이 작업은 브라우저 paint 이전에 실행되지 않으면 의미가 없는데, useEffect로 옮기면 이미 DOM이 그려진 뒤라 조합 문자가 유실된 상태가 되어 복구 자체가 불가능해집니다.

그래서 이 로직은 단순한 상태 동기화가 아니라, React 커밋과 브라우저 paint 사이의 아주 짧은 타이밍에 DOM과 caret 기준점을 다시 세우는 작업이기 때문에 useLayoutEffect를 사용했습니다.

---

## 10. 소켓 이벤트 수신 흐름

### 이벤트 큐잉 — enqueueSocketEvent

소켓에서 이벤트가 오면 즉시 `setState`를 호출하지 않습니다. `enqueueSocketEvent(event)`를 통해 이벤트를 배열에 쌓고, `queueMicrotask()`로 다음 마이크로태스크에서 일괄 처리합니다.

`socketEventQueueRef`는 실행할 함수들을 담는 배열입니다. `isSocketQueueScheduledRef`는 이미 microtask가 예약됐는지 추적하는 플래그입니다. 둘 다 `useRef`를 쓰는 이유는 값이 바뀌어도 리렌더링을 일으키지 않아야 하기 때문입니다.

`enqueueSocketEvent`를 소켓 이벤트가 올 때마다 호출합니다. job을 배열에 push한 뒤, 이미 flush가 예약돼 있으면 그냥 리턴합니다. 예약이 안 됐을 때만 `queueMicrotask(flushSocketEventQueue)`를 호출해서 플러시를 딱 한 번만 예약합니다.

`flushSocketEventQueue` 는 microtask로 실행되는 실제 플러시 함수입니다. 큐를 앞에서부터 하나씩 꺼내 실행합니다. `shift()`를 쓰기 때문에 도착 순서대로 처리됩니다.

각 job을 개별 try-catch로 감싸서, 하나가 에러를 던져도 나머지 job들이 계속 실행됩니다.

finally 블록이 중요합니다. while 루프가 끝난 뒤 `isSocketQueueScheduledRef`를 false로 리셋합니다. 그런데 while 루프가 도는 **도중에** 새 job이 들어왔을 가능성이 있습니다. 그래서 루프 종료 후 큐를 다시 확인하고, 남은 게 있으면 자기 자신을 다시 `queueMicrotask`에 등록합니다.

flush가 실행되는 중에도 `enqueueSocketEvent`가 다시 호출될 수 있습니다. 이때 `isScheduled`가 false이므로 새 microtask를 예약하는데, 사실 현재 flush의 while 루프가 jobD까지 다 처리해버립니다. 그러면 finally에서 큐가 이미 비어있으므로 중복 예약된 microtask가 실행돼도 아무것도 하지 않습니다. 이중 처리가 일어날 것 같지만, 이미 shift()로 빼갔기 때문에 안전합니다.

**왜 즉시 setState를 하지 않나?**
빠른 타이핑 중 소켓 이벤트가 여러 개 연달아 오면, 각 이벤트마다 setState→리렌더링→커서복원이 발생해서 타이핑 경험이 끊깁니다. 큐에 모아서 한 번에 처리하면 리렌더링을 최소화할 수 있습니다.

### TEXT_UPDATE 처리

```
TEXT_UPDATE 이벤트 수신
→ enqueueSocketEvent()로 큐에 추가
→ 마이크로태스크에서 처리
→ OT(Operational Transformation) 로직으로 서버 패치를 현재 text state에 적용
→ setText() 업데이트
→ 영향받은 리뷰 범위 업데이트
```

### TEXT_REPLACE_ALL 처리

서버가 전체 텍스트를 교체해야 하는 상황(초기 로드, conflict 해소 등)에서 전송됩니다.

```
TEXT_REPLACE_ALL 이벤트 수신
→ isComposing 중이면 composingDOMTextRef에 새 텍스트 저장 후 대기
→ isProcessingReplaceAllRef = true (selectionchange 이벤트 차단)
→ replaceAllSignal++ (숫자 변경으로 useLayoutEffect 트리거)
→ useLayoutEffect에서:
   1. 전체 text state를 서버 텍스트로 교체
   2. 모든 리뷰 재계산
   3. restoreCaret()으로 가능한 가장 가까운 위치에 커서 복원
   4. isProcessingReplaceAllRef = false
```

**왜 replaceAllSignal이라는 숫자를 증가시키나?**`useLayoutEffect`는 의존성 배열의 값이 바뀌어야 실행됩니다. 새 텍스트 값을 직접 의존성으로 넣으면 매 타이핑마다 불필요하게 실행될 수 있습니다. 별도 신호 숫자를 증가시켜서 "TEXT_REPLACE_ALL이 왔을 때만" 실행하도록 구분합니다.

**isProcessingReplaceAllRef로 selectionchange를 차단하는 이유**
TEXT_REPLACE_ALL 처리 중 전체 DOM이 교체됩니다. 이 과정에서 Selection이 초기화되어 `selectionchange` 이벤트가 발생할 수 있습니다. 이 이벤트를 처리하면 커서 위치 계산이 잘못되거나 리렌더링 루프가 생깁니다.

---

## 11. 소켓 전송 — 디바운스와 버전 관리

### sendTextPatch의 구조

```
setText() 완료
→ sendTextPatch() 호출
   → forceSocket: true이면:
      1. 진행 중인 디바운스 타이머 flush (아직 안 보낸 패치 즉시 전송)
      2. 새 패치 즉시 전송
   → forceSocket: false이면:
      1. 디바운스 타이머 설정 (N ms 후 전송)
      2. latestTextRef를 최신 text로 업데이트
```

**debounceBaseTextRef vs latestTextRef**

- `debounceBaseTextRef`: 마지막으로 전송된 시점의 텍스트 (diff 계산 기준)
- `latestTextRef`: 현재 최신 text state

빠른 타이핑 시 디바운스 타이머가 여러 번 갱신됩니다. 타이머가 최종 실행될 때 `debounceBaseTextRef`와 `latestTextRef`의 diff를 계산해서 하나의 패치로 묶어 전송합니다.

### reserveNextVersion

소켓 패치를 전송하기 전에 `reserveNextVersion()`으로 버전 번호를 미리 예약합니다. 디바운스 중에도 버전 번호는 이미 확보되어 있으므로, 늦게 전송되어도 서버에서 올바른 OT 적용이 가능합니다.

**버전이 꼬일 가능성은 없나?**
예약(reserve)과 전송 사이에 다른 패치가 먼저 나가는 경우는 없습니다. force 전송 시 반드시 진행 중 디바운스를 먼저 flush하기 때문에, 예약 순서와 전송 순서가 항상 일치합니다.

### lastSentPatchRef — 중복 전송 방지

같은 패치가 두 번 전송되는 시나리오는 드물지만 발생할 수 있습니다. 예를 들어 디바운스 flush 직후 force 전송이 동시에 트리거되는 경우입니다. `lastSentPatchRef`에 마지막 전송 패치를 저장하고, 동일 패치는 전송하지 않습니다.

---

## 12. Tagged Text ↔ Clean Text 인덱스 변환

### 두 가지 텍스트 표현

이 에디터는 내부적으로 두 가지 텍스트 표현을 동시에 유지합니다.

| 구분            | 형태                                          | 용도                                |
| --------------- | --------------------------------------------- | ----------------------------------- |
| **Clean Text**  | `안녕하세요 리뷰된텍스트 나머지`              | 에디터 UI, 사용자에게 보이는 텍스트 |
| **Tagged Text** | `안녕하세요 ⟦r:id001⟧리뷰된텍스트⟦/r⟧ 나머지` | 서버 저장, OT 계산 기준             |

### 왜 ⟦r:id⟧ 형식인가?

HTML 태그(`<span data-id="001">`) 대신 커스텀 마커를 쓰는 이유는 다음과 같습니다.

- HTML 태그는 다양한 길이의 속성을 가질 수 있어 인덱스 계산이 복잡해집니다.
- `⟦r:id⟧`는 길이가 고정적으로 예측 가능합니다 (`⟦r:` + id 길이 + `⟧`).
- 실제 텍스트 내용에서 `⟦` 문자가 등장할 가능성이 극히 낮아 파싱 오류 위험이 낮습니다.

### mapCleanRangeToTaggedRange

Clean text의 인덱스 범위를 Tagged text의 인덱스 범위로 변환합니다.

```
Clean:  "안녕 리뷰텍스트 나머지"
         0123 456789...
                 ↑ index 3

Tagged: "안녕 ⟦r:001⟧리뷰텍스트⟦/r⟧ 나머지"
         0123 456789...
                 ↑ ⟦r:001⟧ 태그만큼 밀림 → index 3 + 8 = 11
```

**insertionBias (before / after)**
리뷰 태그 경계에 정확히 위치한 인덱스는 두 가지로 해석됩니다. "태그 앞"인지 "태그 뒤"인지에 따라 OT 연산 결과가 달라집니다. `insertionBias='before'`면 태그 시작 전 위치, `'after'`면 태그 끝 위치로 변환합니다. 이를 명시하지 않으면 같은 clean index가 태그 안팎의 서로 다른 위치로 변환되어 서버 OT 적용 결과가 예상과 다를 수 있습니다.

**normalizeReviewsForMapping**
태그 토큰의 일부를 삭제하는 것은 무효합니다. 삭제 범위가 `⟦r:id⟧` 내부를 걸치면 태그 전체를 포함하도록 범위를 확장합니다. 이 정규화 없이는 tagged text에 `⟦r:id` 같은 깨진 태그가 남아 서버 파싱이 실패합니다.

---

## 13. 리뷰(댓글) 모달 위치 계산

### 문제: 스크롤에 따라 모달 위치가 달라진다

리뷰 텍스트를 선택하면 댓글 모달이 선택 영역 옆에 떠야 합니다. `getBoundingClientRect()`로 선택 영역의 좌표를 얻으면 뷰포트 기준 값이라 스크롤이 달라지면 위치가 변합니다.

### 해결: selectionHeight (불변 속성 활용)

선택 영역의 **높이(height)**는 스크롤과 무관하게 항상 동일합니다. 이 값을 활용해서 모달의 기준 Y 위치를 스크롤 독립적으로 계산합니다.

```
선택 범위가 생성될 때:
→ selection.getBoundingClientRect()에서 height 추출
→ selectionHeight를 상태로 저장

스크롤 이벤트 발생 시:
→ 현재 스크롤 위치 + selectionHeight로 모달 top 재계산
→ useLayoutEffect에서 modalTop 업데이트

Math.abs(modalTop - selection.modalTop) < 1 가드:
→ 픽셀 단위 부동소수점 오차로 인한 무한 루프 방지
   (modalTop이 1px 미만 차이로 계속 업데이트 → 리렌더링 → useLayoutEffect → 업데이트 반복)
```

---

## 14. 브라우저 기본 동작 vs 직접 구현 — 전체 비교표

| 동작                    | 브라우저 기본                       | 이 에디터                                           | 처리 방식                            |
| ----------------------- | ----------------------------------- | --------------------------------------------------- | ------------------------------------ |
| **문자 입력**           | DOM 텍스트 노드 직접 삽입           | text state 업데이트 후 React 리렌더링               | 막지 않고 DOM 수집 후 state 동기화   |
| **Backspace**           | DOM 노드 직접 제거                  | text state에서 문자 제거                            | `preventDefault` → 직접 구현         |
| **Delete**              | DOM 노드 직접 제거                  | text state에서 문자 제거                            | `preventDefault` → 직접 구현         |
| **Enter**               | `<div>` 또는 `<br>` 삽입            | `\n` 문자 삽입                                      | `preventDefault` → 직접 구현         |
| **IME (한글)**          | 브라우저 조합 관리, DOM 임시 수정   | 조합 이벤트 직접 관리, `flushSync` 동기화           | 커스텀 compositionStart/End 처리     |
| **커서 이동**           | Selection API 자동 관리             | 이동 허용 + 경계에서 normalizeCaretAtReviewBoundary | 막지 않고 후처리                     |
| **복사**                | 현재 선택 내용 그대로 클립보드      | `\u200B` 제거한 순수 텍스트                         | `preventDefault` → 직접 구현         |
| **붙여넣기**            | 서식 있는 HTML 가능                 | 순수 텍스트만                                       | `preventDefault` → `text/plain` 추출 |
| **드래그 선택 후 입력** | 선택 범위 자동 삭제 후 삽입         | 선택 삭제 → 입력 순서 명시적 처리                   | keyDown/compositionStart 두 경로     |
| **렌더링 후 커서 위치** | DOM이 바뀌어도 브라우저가 유지 시도 | 명시적 restoreCaret() 호출                          | useLayoutEffect에서 복원             |

---

## 마치며

이 에디터가 복잡하게 느껴지는 이유는 하나입니다. **contentEditable은 브라우저가 DOM을 마음대로 바꿀 수 있는 영역인데, React는 자신이 DOM을 관리한다는 전제 위에서 동작합니다.** 이 두 가지가 충돌하지 않도록, 브라우저가 DOM을 건드리는 모든 경로를 차단하고 React state를 단일 진실의 원천(Single Source of Truth)으로 유지하는 것이 이 구현의 핵심입니다.

그 위에 IME 타이밍 문제, 리뷰 경계의 커서 처리, 소켓 이벤트와 로컬 편집의 충돌 처리, OT를 위한 인덱스 변환이 층층이 쌓인 구조입니다.
