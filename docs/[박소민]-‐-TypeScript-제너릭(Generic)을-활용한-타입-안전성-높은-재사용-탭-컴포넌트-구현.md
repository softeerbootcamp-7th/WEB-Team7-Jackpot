# 🤔 [고민한 주제]
**TypeScript 제너릭(Generic)을 활용한 타입 안전성 높은 재사용 탭 컴포넌트 구현**

관련 [커밋](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/pull/282/changes/db80c788ad1c50cefd0b272eeb139b225a2d8e61)입니다.

## 📝 고민 배경
- **왜 이 고민을 하게 되었는가?**: 여러 페이지에서 탭 UI를 사용해야 하는데, 페이지마다 탭의 데이터(`props`)와 ID 타입(문자열, 유니온 타입 등)이 제각각임.
- **전제 조건**: React, TypeScript 환경에서 `useState`로 상태를 관리하며, 라이브러리 페이지에서는 `'company' | 'question'`이라는 구체적인 유니온 타입을 사용 중.
- **제약 사항**: 단순히 `string`으로 타입을 넓게 잡으면 오타나 잘못된 값 주입을 막을 수 없음. 반대로 타입을 하드코딩하면 컴포넌트 재사용이 불가능함.

## 🔄 고려한 선택지

### 선택지 1: 타입을 하드코딩하기 (`LibraryView` 직접 사용)
- **개념**: `TabBar` 컴포넌트의 props 타입을 `currentTab: LibraryView`로 고정.
- **장점**: 구현이 매우 단순함. 해당 페이지에서는 완벽하게 타입이 맞음.
- **단점**: **재사용 불가.** 다른 페이지(예: 상품 탭)를 만들 때마다 `ProductTabBar` 같은 새 컴포넌트를 또 만들어야 함.

### 선택지 2: 일반 `string` 타입 사용
- **개념**: `currentTab: string`으로 정의하여 모든 문자열을 허용.
- **장점**: 어떤 탭이든 다 받을 수 있어 재사용성이 높음. 에러가 잘 안 남.
- **단점**: **타입 안전성 포기.** `setTab('banana')` 같은 오타나 로직 에러를 컴파일 타임에 잡을 수 없음.

### 선택지 3: 제너릭(`T`) 활용 (최종 선택)
- **개념**: 컴포넌트와 인터페이스에 `<T>`라는 "타입 변수"를 뚫어두고, 사용하는 시점에 구체적인 타입(예: `LibraryView`)을 주입받음.
- **장점**: **재사용성 + 타입 안전성** 두 마리 토끼를 다 잡음. 사용하는 쪽의 데이터 타입에 맞춰 컴포넌트가 자동으로 변신함.
- **단점**: 문법이 다소 복잡함(화살표 함수 문법, 제약 조건 설정 등). 데이터 배열 정의 시 명시적 타이핑이 필요함.

## ⚖️ 비교 정리

| 항목 | 선택지 1 (하드코딩) | 선택지 2 (string) | 선택지 3 (Generic T) |
|:---:|:---:|:---:|:---:|
| **구현 난이도** | 하 | 하 | **중** |
| **유지보수** | 하 (중복 코드 발생) | 중 (추적 어려움) | **상 (단일 코드 관리)** |
| **타입 안전성** | 상 | 하 | **상** |
| **확장성** | 불가 | 가능 | **우수** |

## ✅ 최종 선택
- **선택한 방안**: **선택지 3 (제너릭 활용)**
- **선택 이유**:
  1. 대기업/실무 환경에서는 컴포넌트의 **재사용성**이 유지보수 비용을 크게 줄여주기 때문.
  2. `LibraryView`처럼 특정 유니온 타입을 강제해야 버그를 사전에 방지할 수 있기 때문.
  3. `useState`의 `set` 함수와 완벽하게 호환되기 때문.

### 💡 핵심 구현 포인트
1. **제약 조건 명시**: `<T extends string>`을 사용하여 T가 최소한 문자열 기반임을 보장.
2. **화살표 함수 문법**: `.tsx` 파싱 에러 방지를 위해 `const TabItem = <T,>(...)` 와 같이 콤마(`,`) 사용.
3. **데이터 타입 일치**: `LibraryContent` 배열 정의 시 `TabContentType<LibraryView>[]`라고 명시하여, 넓은 타입(`string`)으로 추론되는 것을 방지하고 컴포넌트가 원하는 타입(`LibraryView`)과 일치시킴.

## 📉 아쉬운 점
- **포기한 부분**: 코드의 간결함. (초보자가 읽기에는 `<T>` 문법이 생소할 수 있음)
- **리스크**: 외부에서 데이터를 정의할 때 타입을 명시해주지 않으면(`as const`나 타입 지정 누락), "Type mismatch" 에러가 발생하여 초기 설정에 신경을 써야 함.

## 🔮 이후 개선 방향
- **추후 다시 고려할 사항**:
  1. **Compound Component 패턴 도입**: `<Tabs.List>`, `<Tabs.Item>` 형태로 분리하여 레이아웃 유연성 확보.
  2. **URL 연동**: `useState` 대신 URL Query Parameter(`?tab=company`)와 연동하여 새로고침 해도 탭 상태가 유지되도록 고도화 (이때도 제너릭 T는 그대로 유용함).