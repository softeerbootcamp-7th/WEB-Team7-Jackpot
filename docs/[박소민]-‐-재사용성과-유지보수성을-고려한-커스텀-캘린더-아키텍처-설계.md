[🗓️ [구현기] React로 커스텀 캘린더 구현기 보러가기](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/wiki/%5B%EB%B0%95%EC%86%8C%EB%AF%BC%5D-%E2%80%90-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%BA%98%EB%A6%B0%EB%8D%94-%EA%B5%AC%ED%98%84%EA%B8%B0/)

# 🤔 [고민한 주제]
재사용성과 유지보수성을 고려한 커스텀 캘린더 아키텍처 설계 및 관심사 분리(Layered Architecture) 방안
---
(관련 [PR](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/pull/407)입니다.)
- [Data Layer](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/pull/407/changes/f9c28653dc60d42717ee7f886590feda2ed65cf9)
- [Domain Layer](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/commit/820fc3c01201c447b8e156a6653a4f4c63d40f08)
- [Application Layer](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/pull/407/changes/1ac4aad669967c74148384caccc7d3c20bada7a8)
- [Presentation Layer](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/commit/2e5ac12c6e68e6e33d4d5033492c39b4124d0f8d#diff-20c87df0bcba8408ced94c534a81d069aab99fa0b6042f09864faa02acf3db41)

## 📝 고민 배경
- **왜 이 고민을 하게 되었는가?**
  채용 공고 일정(마감일 등)과 개인 일정을 관리하는 캘린더를 구현해야 합니다. 단순한 UI 표출을 넘어, 이후 뷰 타입(월간/주간 등) 확장과 복잡한 비즈니스 로직(날짜 계산, API 연동)이 얽힐 것으로 예상되었습니다. 로직과 UI가 강하게 결합되면 추후의 유지보수가 급격히 어려워질 것을 우려했습니다.
- **전제 조건:**
  React, TypeScript, Tailwind CSS 환경. 여러 명의 프론트엔드 팀원이 함께 코드를 파악하고 작업해야 하므로 예측 가능한 폴더/파일 구조가 필요합니다.
- **제약 사항:**
  무거운 외부 캘린더 라이브러리에 의존하지 않고 직접 구현해야 합니다. 마감 기한이 촉박한 상황이므로, 설계에만 너무 많은 시간을 쏟지 않고 실용적인 수준의 아키텍처를 타협해야 합니다.

## 🔄 고려한 선택지

### 선택지 1: UI 컴포넌트 내부에 모든 로직 구현 (Monolithic)
- **개념:** `Calendar.tsx`라는 단일 파일 안에 날짜 계산(Domain), 상태 관리(Application), 화면 렌더링(Presentation)을 모두 포함하는 방식입니다.
- **장점:** 초기 구현 속도가 매우 빠르고, 파일 이동 없이 한 곳에서 흐름을 파악할 수 있습니다.
- **단점:** 컴포넌트가 비대해져 코드 가독성이 떨어집니다. 추후 다른 형태의 캘린더 UI가 필요해질 경우 핵심 날짜 계산 로직을 중복으로 작성해야 합니다.

### 선택지 2: 커스텀 훅으로 React 상태만 분리 (Presentational & Container)
- **개념:** `useCalendar.ts` 훅을 만들어 현재 달, 선택된 날짜 등의 상태와 이벤트 핸들러만 분리하고, 순수 날짜 계산 로직은 훅 내부에 혼재시키는 방식입니다.
- **장점:** UI 컴포넌트 코드가 깔끔해지고, React 상태에 의존적인 로직을 분리할 수 있습니다.
- **단점:** 훅 자체가 거대해질 수 있으며, React에 의존하지 않는 순수 비즈니스 로직(Domain)이 훅(Application)에 결합되어 있어 로직의 단위 테스트가 까다롭습니다.

### 선택지 3: Layered Architecture 적용 (Domain / Application / Presentation 분리)
- **개념:** 역할을 3단계로 철저히 분리합니다.
  1. **Domain:** 리액트 없이 동작하는 순수 날짜 계산 함수 (`shared/utils/dateUtils.ts`)
  2. **Application:** 상태와 행위를 관리하고 UI에 헬퍼를 제공하는 훅 (`features/calendar/hooks/useCalendar.ts`)
  3. **Presentation:** 훅에서 전달받은 값에 따라 스타일만 그리는 바보 컴포넌트 (`features/calendar/ui/CalendarDay.tsx`)
- **장점:** 관심사가 완벽히 분리되어 팀원들과 협업 시 코드가 어디 있는지 단번에 파악할 수 있습니다. 로직 재사용성이 극대화되고 렌더링 최적화가 쉽습니다.
- **단점:** 초기 디렉터리 설계와 파일 분리 작업에 시간이 소요되며, 아주 단순한 기능 구현에는 오버엔지니어링으로 보일 수 있습니다.

## ⚖️ 비교 정리

| 항목 | 선택지 1 (단일 컴포넌트) | 선택지 2 (상태 훅 분리) | 선택지 3 (Layered 분리) |
|------|----------|----------|----------|
| **구현 난이도 (초기)** | 하 (가장 빠름) | 중 | 상 (설계 고민 필요) |
| **유지보수 및 협업** | 하 (코드 엉킴 심화) | 중 | 상 (역할 분리로 명확함) |
| **성능 (최적화 측면)** | 하 (통째로 리렌더링) | 중 | 상 (관심사 분리로 부분 메모이제이션 용이) |

## ✅ 최종 선택
- **선택한 방안:** **선택지 3 (Layered Architecture 적용)**
- **선택 이유:**
  우리의 목표는 단순히 "코드가 돌아가는 것"이 아니라, 여러 팀원이 지속적으로 기능을 붙이고 관리할 수 있는 환경을 만드는 것입니다. 기능과 공통 계층을 명확히 나누고 UI에서 로직을 걷어냄으로써, 추후 API 데이터(공고 마감일 등)가 추가되더라도 `CalendarDay` 컴포넌트의 Props만 수정하면 되는 유연한 구조를 확보할 수 있습니다. 

## 📉 아쉬운 점
- **포기한 부분:** 극단적인 초기 개발 속도. 공통 훅과 순수 유틸 함수를 세팅하느라 초반 보일러플레이트 코드를 작성하는 시간이 필요했습니다.
- **리스크:** 파일 뎁스가 깊어져 아키텍처 컨벤션에 익숙하지 않은 경우 파일 간 이동이 잦고 복잡하게 느껴질 수 있습니다.

## 🔮 이후 개선 방향
- **추후 다시 고려할 사항:**
  1. **렌더링 최적화:** 날짜 셀 렌더링 시 `React.memo`나 `useMemo`를 적용하여, 불필요한 리렌더링 현상 방지.
  2. **상태 동기화:** 캘린더에서 '현재 보고 있는 연/월' 상태를 `URLSearchParams`를 활용해 URL 쿼리로 관리하여, 새로고침 시에도 사용자가 보던 캘린더 위치가 유지되도록 개선.