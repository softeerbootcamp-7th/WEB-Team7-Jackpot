# 📚 [학습 주제] 뮤테이션 테스트

## 🎯 학습 목표
- 이 내용을 왜 학습했는가? 테스트 커버리지에 대한 학습을 하던 중 AI가 뮤테이션 테스트라는 언급을 해서 궁금하여 학습했다.
- 학습 후 기대 결과: 뮤테이션 테스트를 어떤 경우에 적용할 수 있는지 설명할 수 있다.

## 📖 핵심 내용 요약
- 핵심 개념 1: 인위적 결함 주입 (Fault Injection)
- 핵심 개념 2: 테스트 품질 검증
- 핵심 개념 3: 커버리지의 허상 보완

## ✍️ 상세 정리
### 개념 1: 작동 원리와 돌연변이 생성
설명: 뮤테이션 테스트 도구(Javascript의 Stryker 등)는 소스 코드를 구문 분석하여 다양한 유형의 변이를 적용한다.

- 산술 연산자 변경: `a + b` -> `a - b`
- 조건문 변경: `if (a > 0)` -> `if (a >= 0)` 또는 `if (true)`
- 리턴값 변경: `return true` -> `return false`
- 구문 삭제: 특정 실행 라인을 아예 삭제

```Javascript
// [원본 소스 코드]
function add(a, b) {
  return a + b;
}

// [뮤테이션 도구가 내부적으로 생성한 돌연변이들]

// Mutant 1: 산술 연산자 변경
function add_mutant1(a, b) {
  return a - b; // (+)를 (-)로 바꿈
}

// Mutant 2: 구문 삭제
function add_mutant2(a, b) {
  // return a + b; // 코드를 삭제해버림 (undefined 반환)
}
```

### 개념 2: Survived vs Killed
설명: 뮤테이션 테스트의 핵심은 **뮤턴트를 테스트 코드가 감지를 하는가?** 이다.

- Killed: 테스트를 돌연변이 코드로 돌렸는데 실패 -> 감지 성공
- Survived: 테스트를 돌연변이 코드로 돌렸는데 성공 -> 감지 실패
- Mutation Score = (Killed Mutants / Total Mutants) * 100

### 개념 3: 코드 커버리지의 함정과 보완
설명: 코드 커버리지는 이 줄이 실행되었는지만 보지만 뮤테이션 테스트는 해당 줄이 결과에 영향을 미치는가를 보기 때문에 커버리지가 100%여도 뮤테이션 점수가 0이 나올 수 있다.