# 📖 웹소켓 연결에 관한 정보

## ✨ 한 줄 요약
> 서비스 주요 기능인 실시간 첨삭을 위해 STOMP over SockJS(WebSocket) 연결을 구성하고 구독, 메시지 파싱, 디스패치까지 안정적으로 동작하도록 구현하여 실시간 업데이트를 수신하는 데 성공함

## 🎯 등장 배경
- 왜 이 개념/도구가 등장했는가? 작성자(writer)가 편집 중인 텍스트에 대해 실시간으로 첨삭(리뷰) 이벤트를 즉시 반영해야 해서 양방향 통신이 필요했다.
- 해결하고자 하는 문제:
  - 자기소개서 본문을 작성자(writer)가 편집하는 내용이 첨삭자(reviewer)에게 즉시 반영되어야 함
  - 반대로 첨삭자가 첨삭(리뷰)을 생성/수정/삭제를 했을 때 작성자의 화면에 실시간으로 반영해야 함

## 🔑 핵심 개념
- STOMP over SockJS: 단순 Websocket은 저수준의 프로토콜이므로 메시지 브로커 역할을 하는 STOMP로 pub/sub 구조를 명확히 하고 WebSocket을 지원하지 않는 브라우저 환경에서도 통신이 끊기지 않도록 SockJS로 fallback 메커니즘 적용 (서버 차원)
- 인증 헤더와 재인증: 소켓 연결 시점에 액세스 토큰을 헤더에 담아 보낸다. 만약 토큰이 만료되었다면 연결 시도 직전에 리프레시 토큰으로 재발급받는 로직을 넣어 끊김 없는 실시간성을 보장한다.
- 구독-핸들러 분리: 소켓 연결, 구독, 메시지 핸들링을 훅으로 분리하여 관심사 분리
- 메시지 타입 분기: 수신된 메시지 타입에 따라 클라이언트 상태나 서버 상태를 어떻게 업데이트할지 결정하는 핸들러를 구현

## ⚙️ 동작 방식
1. Handshake & Connect: 클라이언트가 SockJS를 통해 서버에 엔드포인트 접속을 시도하며 STOMP 헤더에 JWT를 넣어 인증을 완료한다.
2. Subscribe: 인증 성공 후 특정 자기소개서 ID / 문항 ID에 해당하는 경로를 구독하여 해당 문항에서 발생하는 모든 이벤트를 기다린다.
3. Message Flow: 첨삭자가 리뷰를 남기면 서버는 구독 중인 클라이언트에게 JSON 메시지를 브로드캐스팅한다. 클라이언트는 이를 파싱하여 UI에 즉시 반영한다.

## 👍 장점
- 양방향 실시간성: HTTP 폴링 방식에 비해 오버헤드가 적고 이벤트 발생 즉시 화면이 갱신되어 사용자 경험이 향상된다.
- 메시지 타입이 많을 수록 분기 처리를 통해 업데이트하면 처리 로직을 나눌 수 있어 유지 보수가 용이해진다.

## 👎 단점
- 연결 유지 비용: 서버와 지속적으로 커넥션을 맺고 있어야 하므로 동시 접속자가 급증할 경우 서버 메모리 부하에 대한 모니터링이 필요하다. (현재 서비스에서는 동시접속자 수 제한이 있음)
- 상태 동기화의 복잡성: 네트워크 순서나 지연으로 인해 로컬 데이터와 서버 데이터 간의 정합성이 깨질 수 있어 이를 해결하기 위해 버전 관리 등이나 예외 처리가 필요하다.

## 🧩 언제 사용하면 좋은가?
- 사용하기 좋은 상황: 협업 도구 개발 시, 데이터 변경 주기가 짧고 즉각적인 반영이 중요한 채팅 등
- 피해야 할 상황: 데이터의 갱신 간격이 길어도 되는 대시보드나 알림 기능처럼 일방향 전달만 필요한 경우 (SSE 사용)