# 🐞 [Troubleshooting] 동시 편집(OT) 알고리즘 구현 중 만난 버전 충돌 개선기

현재 개발 중인 Narratix 서비스는 Writer(작성자)와 Reviewer(첨삭자)가 실시간으로 자소서를 보고 수정할 수 있는 **실시간 첨삭 기능**을 제공합니다. 이를 위해 구글 독스 등에서 사용하는 **OT(Operational Transformation) 알고리즘** 방식을 차용하여 구현하고 있습니다.

하지만 이론을 실제 서비스에 녹여내는 과정에서 예상치 못한 동기화 문제와 UX 저하 이슈를 겪었고, 이를 어떻게 해결해 나갔는지 공유하고자 합니다.

## Operational Transformation 알고리즘
OT는 입력한 순서에 따라 서버가 이를 적절히 변형하여 전달하는 방식입니다. OT 는 시간상의 순서를 고려해 우선 순위를 부여하고, 앞에서 적용할 변경사항이 다음 순위의 변경사항을 보정하는 정보로 사용됩니다.

Narratix에서는 문서가 실시간으로 Reviewer에게 보여져야 합니다. 하지만, 변경된 문서를 항상 Reviewer에게 전달한다면 서버의 부하가 너무 커질 수 있기에 문서 전체를 서버로 전송하는 것이 아니라, 작업(Operation) 단위로 전송합니다. 예를 들어, 시작 위치 3, 끝 위치 3 인덱스에 안녕하세요라는 글자 삽입이라는 작업을 전송하고, 이 변경분들을 모아 하나의 완성된 문서를 만드는 방식입니다.

이 때, 여러 사용자가 동시에 동일한 문서를 편집할 때, 데이터의 일관성을 유지하기 위해 사용하는 동시성 제어 알고리즘입니다. Google Docs와 같은 동시 편집 에디터의 핵심 기술입니다.

## Narratix에서의 Operational Transformation 알고리즘 구현
Narratix에서는 Operational Transformation 알고리즘을 구현하기 위해 Redis의 List를 사용했습니다.
변경분을 저장하기 위해 list를 사용하였고, 아직 DB에 Flush 되지 않은 Delta를 pending delta, DB에 Flush된 Delta를 committed delta로 관리하였고 pending delta에서 committed delta로 delta를 옮기고, Redis 버전을 올리는 작업까지 원자적으로 진행될 수 있도록 Lua Script를 사용했습니다.

그렇다면, OT 알고리즘은 버전을 어떻게 맞출 수 있을까요?
Narratix에서는 동시 편집 충돌이 발생하는 경우가 리뷰어가 댓글을 달 때 리뷰 마커가 생성되기 때문에 이 때 동시편집이 발생한다고 할 수 있습니다.

![이미지 2026  2  27  오전 8 10](https://github.com/user-attachments/assets/83a15bfb-dfa2-441f-ae32-3c4a8c755029)

위 그림을 보시면, 버전 1부터 버전 4까지 문서의 변경분이 어떻게 변해가는지 그림으로 쉽게 알 수 있습니다. 이 때, 버전 1을 보고 있던 Reviewer가 "안녕"이라는 부분에 첨삭 댓글을 다는 Request를 보내면, 그림에 작성된 Flow로 OT Transform을 진행하고, validate를 통해 클라이언트가 현재 정합성이 맞는 버전으로 요청을 보낸 것인지 검증합니다.

Narratix는 이처럼 동시 편집이 발생하는 리뷰 작성의 로직에서 OT 알고리즘을 사용해 충돌을 제어하였습니다.

## 📌 문제 상황 1: 꼬여버린 순서와 무너진 정합성

OT 방식은 **시간 상의 정합성**이 중요한 알고리즘입니다. 문서는 실시간으로 저장되어야 합니다. 하지만 전체 문서를 실시간으로 계속 서버에게 보내면 서버의 부하가 심해지므로, 클라이언트가 전체 문서를 보내는 대신 문서의 변경분인 **Delta**(예: '3번째 인덱스에 A 삽입', '5번째 인덱스 2글자 삭제' 등의 연산 집합)만을 서버로 전송합니다.

Delta는 **바로 이전 버전의 문서 상태에 완벽하게 의존**하여 인덱스를 계산합니다. 따라서 클라이언트가 보낸 Delta가 네트워크 지연 등으로 단 하나라도 누락되거나 순서가 뒤바뀌어 서버에 도달한다면, 문서 전체의 텍스트 인덱스가 밀리며 정합성이 무너질 수 있는 문제가 발생합니다.

초기에는 클라이언트가 보내주는 Delta를 그대로 믿고 서버 문서를 병합했지만, 원인을 알 수 없는 텍스트 깨짐 현상이 빈번하게 발생했습니다.

### 🛠 해결 시도: `expectedVersion`을 통한 낙관적 검증

이 문제를 해결하기 위해, 클라이언트가 Delta를 전송할 때 자신이 알고 있는 현재 문서의 버전인 `expectedVersion`을 함께 담아 보내도록 통신 규격을 변경했습니다.

서버는 다음과 같이 행동합니다.
1. 클라이언트의 `expectedVersion`이 서버가 예상하는 다음 순서가 맞다면 $\rightarrow$ **정상 적용 (버전 up)**
2. 순서가 맞지 않거나 누락이 감지되었다면 $\rightarrow$ **적용 거절 (Reject)**

하지만 현재 클라이언트 측에는 충돌 시 Delta 연산을 다시 계산하고 버전을 자체 관리하는 복잡한 OT 복구 로직이 구현되어 있지 않은 상태였습니다. 따라서 서버가 변경을 거절할 경우, 클라이언트의 상태를 강제로 정상화하기 위해 **`TEXT_REPLACE_ALL`** 이벤트를 발송하여 서버의 최신 전체 문서를 덮어씌우는 방식으로 동기화를 맞추도록 구현했습니다.

## 📌 문제 상황 2: 잦은 롤백으로 인한 불편해진 UX

버전 검증 로직을 넣으니 문서의 정합성이 맞지 않는 문제는 막을 수 있었습니다. 하지만 여기서 두 번째 문제가 발생했습니다.

단기적인 네트워크 불안정으로 Delta 패킷 순서가 살짝만 엇갈려도, 서버는 얄짤없이 `TEXT_REPLACE_ALL` 이벤트를 내려보냈습니다. 이로 인해 Writer가 열심히 키보드를 두드리며 글을 작성하고 있는데, **갑자기 작성 중이던 글이 1~2초 전 상태로 강제 롤백**되어 버리는 현상이 발생한 것입니다. 정합성을 지키려다 유저의 타이핑 경험을 망쳐버리게 되었습니다.

## 🔍 실마리 찾기: 구글 독스는 어떻게 하고 있을까?

해결책을 찾기 위해 동시 편집의 교과서라 할 수 있는 **구글 독스(Google Docs)의 네트워크 탭**을 열어 패킷을 뜯어보았습니다.

관찰 결과, 구글 독스는 사용자가 키보드를 칠 때마다 한 글자 단위로 서버에 데이터를 발송하지 않았습니다. **클라이언트 단에서 사용자의 입력을 짧은 시간(0.5 ~ 1초 정도) 동안 모아두었다가 덩어리로 서버에 발송**하는 로직을 사용하고 있었습니다.

저희 서비스에 이를 대입해 보았습니다.
- 한 글자 단위의 잦은 데이터 전송 $\rightarrow$ 네트워크 패킷 경합 증가, 순서 뒤바뀜 확률 상승.
- 너무 긴 주기의 데이터 전송 $\rightarrow$ Reviewer 화면에서 Writer의 글이 뚝뚝 끊겨 보여 '실시간 첨삭'이라는 기획 의도 훼손.

### 🛠 해결 방법: 클라이언트 디바운싱(Debouncing) 적용

이 두 가지 트레이드오프 사이에서 적절한 타협점을 찾아야 했습니다. 클라이언트 개발자분과 논의하여, 사용자의 입력을 **0.3초에 1번만 서버로 전송하도록 Debouncing 처리**를 요청했습니다.

단일 패킷에 여러 Delta를 묶어서 보내게 되니 패킷 전송 횟수 자체가 획기적으로 줄어들었습니다.

## ✨ 결과 및 향후 개선 방향

디바운싱 적용 결과는 성공적이었습니다. 네트워크 단에서의 순서 엇갈림이 크게 줄어들면서, **`TEXT_REPLACE_ALL` 이벤트의 발생 빈도를 체감상 85% 이상 낮출 수 있었습니다.** Writer의 글이 롤백되는 튕김 현상이 줄어 UX가 향상되었고, 서버의 트래픽 부담도 줄어드는 일석이조의 효과를 얻었습니다.

### **[Future Work]**
물론 현재의 방식(디바운싱 + 서버 주도의 전체 덮어쓰기)은 완벽한 OT의 최종 형태라기보다는 한 달이라는 짧은 개발 기간의 현실적인 제약 속에서 찾아낸 타협안입니다.

향후에는 클라이언트 측에 **ACK 메커니즘**을 도입한다면, 서버로부터 승인받지 못한 Delta를 클라이언트가 스스로 재변환 또는 재전송하여 적용할 수 있도록 할 수 있다고 생각합니다. TCP가 ACK과 재전송을 통해 전송 순서를 보장하는 것처럼 서버 주도의 전체 덮어쓰기를 최대한 막아낼 수 있을 것이라고 생각합니다.