## 들어가며

자소서 첨삭 서비스를 개발하면서 **Writer(작성자)와 Reviewer(검토자)가 같은 문서를 실시간으로 함께 보는** 기능이 필요했습니다. Writer는 텍스트를 수정하고, Reviewer는 특정 구간을 드래그해 리뷰를 달거나 수정 제안을 남깁니다. 두 사람이 같은 화면을 보고 있으므로, 한쪽의 행동이 반대편에 즉시 반영되어야 합니다.

언뜻 보면 단순해 보이지만, 실제로는 까다로운 문제들이 숨어 있었습니다. 텍스트 변경과 리뷰 생성이 **별개의 이벤트로 쪼개져서 순서대로 도착**하고, 서버가 보내는 인덱스는 **태그가 포함된 텍스트 기준**인데 프론트엔드는 **태그가 없는 순수 텍스트**를 다루고 있으며, React의 비동기 렌더링 특성 때문에 이벤트가 연속으로 도착하면 **이전 이벤트의 결과가 아직 state에 반영되기 전에 다음 이벤트가 처리**될 수 있었습니다.

이 글에서는 이러한 문제들을 어떻게 정의하고, 어떤 구조로 해결했는지 설명합니다.

---

## 1. 전체 구조를 잡기 전에 한 고민

가장 먼저 결정해야 했던 것은 **WebSocket 관련 코드를 어디에 둘 것인가**였습니다.

처음에는 상태 관리 훅(`useReviewState`) 안에 WebSocket 구독 로직까지 함께 넣는 방안을 생각했습니다. 하지만 이 방식에는 문제가 있었습니다. `useReviewState`는 Writer(`CoverLetterLiveMode`)와 Reviewer(`ReviewLayout`) 양쪽에서 동일하게 사용되는 훅인데, 두 컴포넌트의 WebSocket 연결 방식이 미묘하게 다릅니다. Reviewer는 `SHARE_DEACTIVATED`라는 별도 메시지를 받아서 페이지를 이동시켜야 하고, Writer는 텍스트 변경 시 서버로 메시지를 발송해야 합니다. 이런 차이를 하나의 훅에 모두 담으면 관심사가 뒤섞이게 됩니다.

그래서 결론은 **`useReviewState`는 WebSocket을 전혀 모르게 한다**는 것이었습니다. 훅은 "어떤 데이터가 들어오면 상태를 어떻게 바꿀 것인가"만 책임지고, WebSocket 연결·구독·메시지 수신은 각 컴포넌트가 직접 처리하도록 나눴습니다.

결과적으로 전체 구조는 아래처럼 역할이 명확하게 분리됐습니다.

```c
CoverLetterLiveMode (Writer)
  ├── useStompClient()       ← STOMP 연결 수립, 재연결, sendMessage 제공
  ├── useReviewState()       ← 문서·리뷰 상태 관리, dispatchers 노출
  ├── useSocketSubscribe()   ← 토픽 구독/해제, 메시지를 onMessage 콜백으로 전달
  └── useSocketMessage()     ← 이벤트 타입 분기 → dispatchers 호출
```

```c
ReviewLayout (Reviewer)
  ├── useStompClient()
  ├── useReviewState()
  ├── useSocketSubscribe()
  └── useSocketMessage()
```

`useSocketMessage`는 switch 분기만 담당하는 얇은 레이어로, 타입에 따라 알맞은 dispatcher를 호출하는 것 외엔 아무것도 하지 않습니다. 덕분에 `useReviewState`는 WebSocket 없이도 테스트할 수 있고, 두 컴포넌트가 동일한 훅을 코드 중복 없이 재사용할 수 있습니다.

---

## 2. STOMP 연결: 놓치기 쉬운 세부사항들

WebSocket 연결은 `@stomp/stompjs`와 `sockjs-client`를 조합해서 구현했습니다. 라이브러리 자체는 간단하지만, 실제 서비스에 쓰려면 신경 써야 할 부분이 몇 가지 있었습니다.

**소켓 팩토리를 콜백으로 넘겨야 합니다.** 처음엔 `new SockJS(...)` 인스턴스를 직접 넘겼는데, 그러면 재연결 시 이미 닫힌 소켓을 재사용하려다 실패합니다. 이미 만들어진 소켓 객체가 아니라 새 소켓을 생성하는 팩토리 함수를 `webSocketFactory`에 넘겨야 자동 재연결이 올바르게 동작합니다.

**연결 직전에 토큰을 갱신합니다.** `beforeConnect` 콜백에서 토큰 refresh를 먼저 시도하고, 성공하면 갱신된 토큰을, 실패하면 기존 access token을 연결 헤더에 담습니다. 재연결이 반복되는 상황에서도 항상 최신 토큰으로 시도하기 위함입니다. 단, 서버가 인증 오류를 돌려주면 재연결을 아무리 반복해도 소용이 없으므로, `onStompError`에서 auth 관련 오류를 감지하면 즉시 클라이언트를 비활성화합니다.

**heartbeat 설정이 중요합니다.** 4초 간격으로 양방향 heartbeat를 설정했습니다. 이 값이 없으면 중간 네트워크 장비가 idle 연결을 조용히 끊어버리는 경우가 있는데, heartbeat가 있으면 연결이 살아있음을 주기적으로 확인하고 끊겼을 때 빠르게 감지해 재연결(5초 후)로 이어집니다.

---

## 3. 구독 관리: stale closure와의 싸움

`useSocketSubscribe`는 STOMP 토픽 구독을 관리하는 훅입니다. 이 훅에서 가장 중요하게 다룬 것은 **stale closure 문제**였습니다.

WebSocket 메시지를 받았을 때 호출할 `onMessage` 콜백을 단순히 `useEffect` 의존성 배열에 넣으면, 콜백이 바뀔 때마다 effect가 재실행되어 구독이 불필요하게 해제·재설정됩니다. 반대로 의존성 배열에서 빼면, 처음 구독 시점의 콜백이 클로저에 고정되어 이후 상태가 바뀌어도 오래된 값을 참조하게 됩니다.

해결책은 콜백을 ref에 담아두는 것입니다. `onMessageRef.current = onMessage`로 항상 최신 콜백을 ref에 유지하고, 실제 구독 핸들러 안에서는 `onMessageRef.current?.(parsedBody)`를 호출합니다. 이렇게 하면 구독 자체는 `qnaId`나 연결 상태가 바뀔 때만 재설정되고, 콜백은 항상 최신 버전이 호출됩니다.

`qnaId`가 바뀌는 경우도 중요합니다. 자소서에 여러 문항이 있고 페이지를 이동하면 구독 토픽이 바뀌어야 합니다. effect cleanup에서 이전 구독을 명시적으로 해제하고, 새 `qnaId`로 새 구독을 설정합니다.

---

## 4. 소켓 이벤트 큐: React 비동기 렌더링과의 동기화

이 프로젝트에서 가장 까다로웠던 부분입니다. 문제를 이해하려면 먼저 이벤트가 어떤 순서로 도착하는지를 알아야 합니다.

리뷰가 생성되면 서버는 두 개의 이벤트를 연달아 보냅니다. 먼저 `TEXT_REPLACE_ALL`로 태그가 삽입된 전체 텍스트를 보내고, 바로 뒤이어 `REVIEW_CREATED`로 리뷰의 메타데이터(작성자, 코멘트 등)를 보냅니다. `REVIEW_CREATED` 핸들러는 앞서 도착한 `TEXT_REPLACE_ALL`이 파싱해둔 태그 위치 정보를 참조해야 합니다.

문제는 여기서 발생합니다. `TEXT_REPLACE_ALL`을 처리하면서 `setState`를 호출해도, React는 해당 렌더링을 **비동기적으로 처리**합니다. 렌더링이 완료되기 전에 `REVIEW_CREATED`가 도착하면, `REVIEW_CREATED` 핸들러는 아직 반영되지 않은 이전 상태를 바라보게 됩니다.

이 문제를 해결하기 위해 두 가지 접근을 병행했습니다.

첫 번째는 **ref를 즉시 동기화**하는 것입니다. `setState`를 호출하는 동시에, 같은 값을 ref에도 즉시 씁니다. 다음 이벤트 핸들러는 state 대신 ref에서 최신 값을 읽으므로, React 렌더링 타이밍과 무관하게 항상 직전 이벤트의 결과를 기준으로 계산할 수 있습니다.

두 번째는 **마이크로태스크 기반 이벤트 큐**입니다. 모든 소켓 이벤트 핸들러 호출을 즉시 실행하는 대신 큐에 쌓아두고, `queueMicrotask`로 현재 태스크가 끝난 직후에 순서대로 실행합니다. WebSocket 메시지들이 짧은 시간 안에 여러 개 도착해도, 큐가 도착 순서를 보장하고 각 이벤트는 이전 이벤트가 ref에 반영한 결과를 바탕으로 처리됩니다.

```c
[TEXT_REPLACE_ALL 도착] → 큐에 enqueue
[REVIEW_CREATED 도착]   → 큐에 enqueue
↓ queueMicrotask
TEXT_REPLACE_ALL 핸들러 실행 → ref 즉시 업데이트 + setState
REVIEW_CREATED 핸들러 실행  → ref에서 최신 태그 위치 참조 → setState
```

---

## 5. 태그드 텍스트 포맷: 서버와 클라이언트의 언어 통일

서버와 클라이언트는 리뷰 위치를 표현하는 방식이 다릅니다. 서버는 텍스트 안에 특수 태그를 삽입해서 리뷰 구간을 표시합니다.

`"안녕하세요 ⟦r:42⟧오늘은 날씨가⟦/r⟧ 맑습니다"`

`⟦r:42⟧`는 id가 42인 리뷰의 시작, `⟦/r⟧`는 끝을 나타냅니다. 이 포맷에는 이유가 있습니다. 텍스트 인덱스만으로 리뷰 위치를 전달하면, 서버와 클라이언트의 텍스트 상태가 조금이라도 어긋난 순간 위치가 틀어집니다. 태그를 텍스트 안에 인라인으로 넣으면 텍스트와 위치 정보가 항상 함께 움직이므로, 동기화 오류에 훨씬 강건합니다.

하지만 프론트엔드 에디터는 이 태그가 없는 순수 텍스트를 다룹니다. 태그가 섞인 텍스트를 사용자에게 보여줄 수 없으니까요. 그래서 `parseTaggedText` 함수가 태그를 제거한 **clean text**와 각 리뷰의 clean text 기준 범위를 담은 **taggedRanges** 배열을 분리해서 반환합니다. 에디터는 clean text를 화면에 보여주고, taggedRanges는 리뷰 하이라이트 위치를 계산하는 데 씁니다.

반대 방향도 필요합니다. Writer가 텍스트를 수정하면 그 변경 위치를 서버에 알려야 하는데, 서버는 태그 포함 텍스트 기준 인덱스를 기대합니다. 이때 `reconstructTaggedText`가 현재 clean text와 리뷰 위치를 받아 태그가 삽입된 원본 형태로 다시 조립합니다. 태그 인라인 포맷 덕분에 이 변환이 가능합니다.

---

## 6. 이벤트별 상태 반영 로직

### TEXT_UPDATE: Writer의 타이핑을 반대편에 반영

Writer가 타이핑할 때마다 서버가 변경 delta를 broadcast합니다. 페이로드는 `{ version, startIdx, endIdx, replacedText }`로, "태그 포함 텍스트에서 startIdx~endIdx 구간을 replacedText로 교체하라"는 의미입니다.

문제는 프론트엔드가 clean text를 들고 있다는 점입니다. 태그 포함 텍스트 기준 인덱스를 clean text에 바로 적용할 수 없습니다. 처리 순서는 이렇습니다.

현재 clean text와 리뷰 위치로 태그 포함 텍스트를 역으로 재구성하고, 거기에 서버가 보낸 delta를 적용한 뒤, 다시 파싱해서 새 clean text와 새 태그 위치를 얻습니다. 이 과정을 통해 "서버가 보낸 태그 기준 인덱스"와 "프론트엔드의 clean text" 사이의 간극을 메웁니다.

버전 관리도 이 이벤트에서 중요합니다. 이미 처리한 버전보다 낮거나 같은 버전이 들어오면 무시합니다. Writer가 로컬에서 낙관적으로 버전을 올린 뒤 서버 echo가 돌아오는 경우, 또는 네트워크 재전송 상황에서 동일 이벤트가 중복 도착하는 경우를 막기 위함입니다.

### TEXT_REPLACE_ALL: 전체 스냅샷으로 상태 동기화

리뷰가 생성되거나 삭제될 때 서버는 태그가 추가/제거된 전체 텍스트를 `content` 필드로 보내줍니다. delta가 아니라 현재 서버 상태의 완전한 스냅샷입니다.

이 이벤트는 `TEXT_UPDATE`와 달리 버전 비교 없이 항상 적용합니다. 서버 스냅샷이 현재 클라이언트 상태보다 무조건 정확하기 때문입니다. Writer가 타이핑하면서 로컬 버전을 앞서 올렸더라도 덮어씁니다.

처리 후에는 `replaceAllSignal`을 1 증가시킵니다. 이 신호는 contentEditable 에디터에게 전달되어 강제 전체 재렌더링을 유발합니다. 텍스트 전체가 바뀌었으므로 에디터도 완전히 새로 그려야 하기 때문입니다. selection도 이 시점에 무효화됩니다.

이벤트 처리의 끝에서 파싱한 `taggedRanges`를 `lastTaggedRangesRef`에 저장합니다. 곧이어 도착할 `REVIEW_CREATED`가 이 정보를 참조하기 때문입니다.

### REVIEW_CREATED: 2단계 시퀀스의 두 번째 단계

`TEXT_REPLACE_ALL`이 텍스트와 태그 위치를 먼저 세팅하고, `REVIEW_CREATED`가 리뷰의 메타데이터(작성자 정보, 코멘트, 제안 텍스트 등)를 채워 넣습니다.

핸들러는 `lastTaggedRangesRef`에서 `reviewId`에 해당하는 범위를 찾아 Review 객체를 만듭니다. 만약 태그 위치를 찾지 못하면 `{ start: -1, end: -1 }`로 설정합니다. 이는 위치를 추적할 수 없는 리뷰를 뜻하며, 이후 `viewStatus` 계산에서 `OUTDATED`로 처리됩니다.

동일 id의 리뷰가 이미 있으면 교체하고, 없으면 배열 뒤에 추가합니다. 소켓 이벤트 재전송이나 중복 도착에 대한 방어 처리입니다.

### REVIEW_DELETED: 조용한 제거

가장 단순한 이벤트입니다. 받은 `reviewId`를 리뷰 배열에서 필터링해서 제거합니다. 한 가지 추가로 신경 쓸 부분은, 삭제된 리뷰가 현재 편집 중인 리뷰라면 편집 상태도 함께 초기화하는 것입니다. 유저가 편집 폼을 열어둔 채로 다른 사람이 같은 리뷰를 삭제하는 경우를 막기 위함입니다.

### REVIEW_UPDATED: 수정과 승인 토글을 하나로

리뷰 수정과 리뷰 승인·되돌리기 모두 이 이벤트로 처리됩니다. 페이로드에 `isApproved` 필드가 명시적으로 있으면 그대로 씁니다. 없는 경우가 복잡한데, 이때는 **swap 패턴**으로 승인 여부를 추론합니다.

승인 또는 되돌리기 시 서버는 `originText`와 `suggest`를 서로 뒤바꿔서 보냅니다. 즉, 이전에 갖고 있던 리뷰의 `originText`가 들어오는 `suggest`와 같고, 이전 `suggest`가 들어오는 `originText`와 같다면 swap 이벤트로 판단하고 `isApproved`를 토글합니다. 단, `originText === suggest`인 경우에는 swap인지 단순 수정인지 구분할 수 없으므로 이 로직에서 제외합니다.

---

## 7. 낙관적 업데이트: 어디에 쓰고 어디에 쓰지 않을까

모든 동작을 소켓 이벤트 수신 후에 반영하면 가장 안전하지만, 사용자 경험이 나빠집니다. Writer가 타이핑할 때마다 서버 응답을 기다리면 입력 지연이 느껴집니다.

반대로 모든 동작을 낙관적으로 즉시 반영하면 서버 응답과 충돌이 생길 수 있습니다. 리뷰 생성의 경우, 클라이언트가 먼저 리뷰를 화면에 띄웠는데 서버에서 `TEXT_REPLACE_ALL`이 오면 텍스트 전체가 덮어씌워지면서 위치 정보가 어긋납니다.

그래서 동작의 특성에 따라 정책을 다르게 가져갔습니다.

Writer의 타이핑은 즉시 로컬에 반영하고 소켓으로도 발송합니다. 입력 지연이 없어야 하고, 텍스트 변경은 충돌 시 버전 비교로 처리할 수 있기 때문입니다. 리뷰 수정도 수정한 본인은 즉시 반영하고, 상대방은 소켓 이벤트 수신 후 반영합니다.

반면 리뷰 생성과 삭제, 승인은 낙관적 업데이트 없이 소켓 이벤트 수신 후에만 반영합니다. 이 동작들은 서버가 텍스트 전체를 재전송(`TEXT_REPLACE_ALL`)하기 때문에, 미리 클라이언트에 반영해도 곧 덮어씌워집니다. 오히려 중간 상태가 잠깐 깜빡이는 것처럼 보일 수 있어서, 아예 기다렸다가 한 번에 반영하는 것이 더 자연스럽습니다.

---

## 8. viewStatus: 리뷰가 지금 어떤 상태인가

리뷰는 단순히 "있다/없다"가 아니라, 현재 문서 텍스트를 기준으로 **어떤 상태인지**를 계산해서 보여줍니다. 이 계산을 담당하는 것이 `computeViewStatus`입니다.

기본 아이디어는 간단합니다. 리뷰가 가리키는 범위의 텍스트가 원문(`originText`)과 같으면 아직 적용 전인 `PENDING` 상태, 제안 텍스트(`suggest`)와 같으면 제안이 반영된 `ACCEPTED` 상태입니다. 범위가 무효화(`start: -1`)된 리뷰는 `OUTDATED`로 처리합니다.

`isApproved` 플래그가 있으면 약간 달라집니다. 이미 승인된 리뷰는 원문이나 제안 텍스트가 범위에 있어야 `ACCEPTED`고, 그렇지 않으면 `OUTDATED`입니다. 승인 후 다시 원문으로 되돌린 경우(`REVERT`)도 별도로 처리합니다.

중요한 점은 이 계산이 **상태 업데이트 경로와 무관하게 항상 실행**된다는 것입니다. 로컬 입력이든 소켓 이벤트 수신이든, 텍스트가 바뀔 때마다 `applyViewStatus`를 통해 모든 리뷰의 `viewStatus`가 최신 텍스트 기준으로 재계산됩니다. 덕분에 여러 경로로 상태가 업데이트되더라도 화면에 표시되는 리뷰 상태는 항상 일관됩니다.

---

## 9. Writer와 Reviewer의 차이점

두 컴포넌트 모두 같은 `useReviewState`를 쓰지만, 컴포넌트 레벨에서 다르게 동작하는 부분이 있습니다.

**Writer(`CoverLetterLiveMode`)** 는 `sendMessage`를 에디터로 내려보냅니다. 에디터에서 텍스트가 바뀌면 변경 내용을 서버로 발송하고, `reserveNextVersion`으로 버전을 미리 올려둔 뒤 소켓 메시지에 담아 보냅니다.

**Reviewer(`ReviewLayout`)** 는 텍스트를 수신만 합니다. `sendMessage`를 받지 않습니다. 대신 `SHARE_DEACTIVATED` 메시지를 별도로 처리합니다. 작성자가 공유 링크를 비활성화하면 이 메시지가 오는데, `isWebSocketResponse` 타입 가드를 통과하지 않아서 일반 이벤트 라우팅으로는 처리되지 않습니다. `onMessage` 콜백에서 먼저 `isShareDeactivatedMessage`로 확인하고, 해당하면 알림을 띄우고 홈으로 이동시킵니다.