# 트랜잭션 경계 재설계와 낙관적 락을 통한 리뷰 생성 로직 개선

실시간 첨삭 서비스인 Narratix에서 첨삭 댓글(Review) 생성은 핵심적이면서도 다루기 까다로운 작업이었습니다. 사용자가 텍스트에 댓글을 다는 순간, 서버 내부에서는 11단계의 복잡한 파이프라인이 동작해야 합니다.

1. QnA 엔티티 조회
2. ShareLink와 Redis Lock을 조회하여 접속 유저 검증
3. Redis에서 아직 DB에 반영되지 않은 Pending Delta 조회
4. DB에서 이미 반영된 Committed Delta 조회
5. OT(Operational Transformation) 연산을 통한 인덱스 변환 및 정합성 검증
6. Review 엔티티 생성 및 저장
7. QnA 버전 업데이트 및 Answer 텍스트에 Review 마커(`[r:id]...[/r]`) 추가
8. Redis 버전 업데이트
9. 웹소켓으로 리뷰 생성 이벤트 메시지 브로드캐스팅
10. 웹소켓으로 TEXT_REPLACE_ALL 메시지 브로드캐스팅
11. Writer에게 첨삭 도착 알림(Notification) 생성 및 발송

## 🚨 문제 상황: 파편화된 트랜잭션과 거대 트랜잭션의 딜레마

초기에는 위 11단계의 작업들이 각각 개별적인 트랜잭션 또는 함수로 순차 실행되도록 구현되어 있었습니다. 그러다 보니 중간 단계에서 에러가 발생하면 심각한 문제가 생겼습니다. 예를 들어, 6번(Review 생성)은 성공했는데 7번(QnA 업데이트)에서 예외가 발생하면 시스템의 데이터 정합성이 완전히 어긋나버리는 **파편화 문제**가 발생했습니다.

그렇다고 이 11단계를 하나의 거대한 `@Transactional`로 묶는다면, **트랜잭션 내부에 Redis I/O나 WebSocket 통신 같은 네트워크 I/O가 포함될 수 있습니다. 이 경우, 외부 응답을 기다리는 동안 DB 커넥션을 놓지 않아 심각한 성능 병목을 유발**할 수 있습니다. 게다가 Redis 연산은 RDB 트랜잭션이 롤백된다고 해서 함께 롤백되지 않으므로 정합성을 보장할 수도 없었습니다.

결국 "**롤백이 필요한 진짜 범위는 어디까지인가?**"에 대한 깊은 고민이 필요했습니다.

## 🔍 로직 분석: Query와 Command의 분리

우선 DB 접근이 필요한 로직들을 성격에 따라 '조회(Query)'와 '수정/생성(Command)'으로 분류해 보았습니다.

- **[Query]** 1. QnA 조회
- **[Query]** 2. ShareLink 및 Redis Lock 검증
- **[Command]** 6. Review 생성
- **[Command]** 7. QnA 버전 업데이트 및 마커 추가
- **[Command]** 11. 알림(Notification) 발송

조회(Query) 로직은 실패하더라도 DB 상태를 변경하지 않으므로 롤백이 필요 없습니다. 반면 생성/수정(Command) 로직은 도중에 실패하면 이전 상태로 롤백되어야 합니다. 저는 이 기준을 바탕으로, 전체 로직의 순서를 해치지 않는 선에서 트랜잭션 경계를 3개로 쪼갰습니다.

---

## 🛠 해결책 1: 트랜잭션 경계의 재설정

### [트랜잭션 1] Read-Only 구간

`@Transactional(readOnly = true)`를 적용하여 성능을 최적화하고 락 타임을 최소화합니다.
- 1. QnA 조회
- 2. ShareLink 및 Redis Lock 검증

### [Non-Transaction] 무거운 연산 및 Network I/O 구간
DB 커넥션을 반환한(트랜잭션을 종료한) 상태에서 외부 I/O와 무거운 OT 변환 로직을 수행합니다. 이 부분이 동시 편집의 핵심입니다.
- 3. Pending Delta (Redis) 조회
- 4. Committed Delta (DB) 조회
- 5. OT 변환 및 정합성 검증

> **📌 [참고] OT 변환 로직은 어떻게 동작할까요?** <br><br>
> 동시 편집 환경에서는 클라이언트와 서버의 버전이 일치하지 않을 수 있으므로, 서버 측의 보정 작업이 필수적입니다.<br><br>
> **[초기 상태]**
> - DB (Committed): `answer` = "ABC", `version` = 10
> - Redis (Pending): `[v11(D 추가), v12(E 추가)]` (2개의 Delta 대기 중)
> - 서버의 최종 예상 텍스트: "ABCDE", 최신 버전: 12
> 
> **[클라이언트 요청 상황]**
> - Reviewer의 클라이언트는 네트워크 지연으로 아직 v10 ("ABC") 상태를 보고 있습니다.
> - Reviewer가 문자 "B"에 첨삭 댓글을 달기 위해 서버로 요청을 보냅니다. (요청 인덱스: 1, 클라이언트 버전: 10)
> 
> **[서버 측 처리 흐름]**
> 1. **조회:** Redis에서 `pendingDeltas = [v11, v12]`를 조회합니다. (`pendingDeltaCount = 2`)
> 2. **변환(OT):** Reviewer의 요청은 v10 기준 인덱스(1)입니다. 서버는 v11, v12의 변경분을 순차적으로 적용하여, Reviewer의 타겟 인덱스를 최신 버전(v12) 기준으로 이동(Shift)시킵니다.
> 3. **검증:** 변환된 최종 인덱스가 서버가 계산한 원문("ABCDE")의 텍스트("B")와 정확히 일치하는지 확인합니다. 일치하면 서버와 클라이언트의 정합성이 맞다고 판단하여 통과시킵니다!

### [트랜잭션 2] 핵심 데이터 생성 및 업데이트 (Write)

수정된 데이터를 실제로 DB에 반영하며, 도중 실패 시 롤백을 보장하는 메인 트랜잭션입니다.
- 6. Review 생성
- 7. QnA 버전 업데이트 및 마커 추가
- 8. Redis 버전 업데이트

> **📌 Redis는 네트워크 IO인데 왜 트랜잭션에 포함했나요?**
> Redis 버전 업데이트 로직이 QnA의 버전 업데이트와 함께 진행되어야 하는 원자성을 보장해야 하는 로직이기 때문입니다.
> 이 때, Redis는 트랜잭션 경계를 설정하더라도 롤백이 불가능한 점을 감안하여 트랜잭션 마지막 부분에 Redis 버전 업데이트 로직을 작성하여 앞선 DB 업데이트가 모두 성공한 직후에 실행되도록 하여 실패 리스크를 최소화하고 예외 발생 시 DB 트랜잭션을 즉시 롤백시킵니다.
### [트랜잭션 3 & 비동기] 부가 로직
- 9,10. WebSocket 메시지 발송 (비동기 처리로 격리)
- 11. Notification Entity 발송 (메인 비즈니스 로직과 트랜잭션 분리)

Notification의 실패가 Review 생성 실패로 이어지면 안되기 때문에, 트랜잭션과 관련되지 않은 로직들은 트랜잭션 커밋 후 이벤트를 발행하는 `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`를 적용해주었습니다.

---

## ⚡ 해결책 2: 쪼개진 트랜잭션, 낙관적 락(Optimistic Lock)으로 방어하기

성격에 맞게 트랜잭션을 분리하여 DB 커넥션 낭비를 막아낼 수 있었지만, 피할 수 없는 동시성 문제가 남았습니다.

`[트랜잭션 1]`에서 QnA를 조회한 뒤, 트랜잭션 밖에서 네트워크 I/O와 OT 연산을 수행하고, 다시 `[트랜잭션 2]`로 진입하여 QnA를 업데이트하는 구조입니다. 즉, **첫 조회와 실제 업데이트 사이에 DB 락이 풀려있는 틈이 존재**합니다. 이 틈에 Writer가 텍스트를 수정하여 QnA의 버전을 먼저 올려버리면 정합성이 무너질 수 있었습니다.

따라서, 이를 방어하기 위해 **낙관적 락(Optimistic Lock, `@Version`)** 을 도입했습니다. QnA 엔티티에는 이미 OT 관리를 위한 `version` 필드가 있었기에 이를 사용하여 쉽게 적용할 수 있었습니다.

### 🛡️ Retryable과 TEXT_REPLACE_ALL을 활용한 안전망 구축
마지막으로, 낙관적 락이 실패했을 때, Spring의 `@Retryable`을 도입하여 **최대 2번까지 리뷰 생성 로직을 재시도**하도록 구현했습니다. 만약 2번의 재시도조차 모두 실패한다면, 이는 정합성이 심각하게 어긋났음을 의미합니다. 이때는 Fallback으로 클라이언트에게 **`TEXT_REPLACE_ALL`** 이벤트를 웹소켓으로 발송합니다. 이를 통해 Reviewer와 Writer의 화면을 서버의 최신 원본 텍스트로 강제 동기화하여, 더 이상의 데이터 오염을 막고 안전한 상태로 복구될 수 있도록 하였습니다.

## ✨ 결론
복잡하게 얽혀있던 11단계의 리뷰 생성 로직을 쿼리의 성격과 네트워크 I/O 여부에 따라 전략적으로 쪼개어 배치했습니다. 이를 통해 DB 커넥션 점유 문제를 해결하면서도, 낙관적 락과 재시도 메커니즘을 통해 분산된 트랜잭션 간의 데이터 무결성을 지켜낼 수 있었습니다. "트랜잭션 경계를 분석하여 명확하게 분리해야한다"라는 점을 배울 수 있었던 최적화 경험이었습니다.