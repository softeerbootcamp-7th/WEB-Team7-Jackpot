# 🤔 [고민한 주제]
**복잡한 탭/페이지 환경에서 URL 파라미터와 로컬 스토리지, React 상태 간의 완벽한 동기화 및 깜빡임(Flicker) 없는 UX 설계**

## 📝 고민 배경
- **왜 이 고민을 하게 되었는가?**
  검색어 입력, 폴더 선택, 문항 진입 등 다양한 상태가 존재하는데, 탭을 전환하거나 다른 페이지에 다녀올 때 이 상태들이 초기화되거나 엉뚱한 시점에 렌더링되어 화면 깜빡임(Skeleton 지연)과 좀비 파라미터 버그가 발생함. 또한 페이지마다 상태 유지/초기화 요구사항이 달라 구조적인 해결책이 필요했음.
- **전제 조건:**
  - 사용자가 탭을 전환하거나 이탈 후 복귀해도 이전 검색어와 선택된 폴더/문항 상태가 완벽히 복구되어야 함.
  - URL을 공유하거나 새로고침했을 때도 동일한 상태가 보여야 함.
  - 상태 복구 과정에서 사용자에게 '폴더 리스트가 잠깐 보였다가 검색 결과로 바뀌는' 1프레임의 시각적 불쾌감(Flicker)이 없어야 함.
- **제약 사항:**
  - React 18의 엄격한 렌더링 사이클 준수 (`Cannot access refs during render`, `Calling Effect` 등 안티 패턴 회피).
  - React Router의 상태 병합(Batching)으로 인한 비동기 라우팅 충돌(Race condition) 방지.

## 🔄 고려한 선택지

### 선택지 1: 컴포넌트 내부에 Effect와 상태 로직 집중 (초기 접근)
- **개념:** `LibrarySearchResult` 등 UI 컴포넌트 안에서 `useEffect`를 무차별적으로 사용하여 로컬 스토리지를 읽고, URL을 업데이트하며 내부 상태(`setState`)를 갱신하는 방식.
- **장점:** 특정 페이지의 비즈니스 로직을 한눈에 파악하기 쉽고 초기 구현 속도가 빠름.
- **단점:** `useEffect` 연쇄 호출로 인한 폭포수 렌더링(Waterfall Rendering) 발생. 화면 깜빡임을 제어하기 힘들며, React가 강하게 경고하는 'Calling Effect' 안티 패턴을 유발함. 다른 페이지에서 로직 재사용 불가.

### 선택지 2: 거대한 만능 Custom Hook 하나로 통합 (`useSearch` 비대화)
- **개념:** `useSearch` 훅 하나에 검색어 디바운싱, 페이지네이션, URL/Storage 동기화뿐만 아니라 특정 도메인의 폴더/문항 선택(`qna-name`, `qna-id`) 로직까지 모두 때려 넣는 방식.
- **장점:** UI 컴포넌트는 매우 깔끔해짐. 단일 진입점(Single Source of Truth)을 확보할 수 있음.
- **단점:** 훅의 책임이 너무 많아져 단일 책임 원칙(SRP) 위배. 검색 기능만 필요한 랜딩 페이지와 선택 상태까지 필요한 작성 페이지 간의 호환성이 깨지며 확장성이 심각하게 저하됨.

### 선택지 3: 관심사 분리(SoC)를 통한 훅 수평 분할 및 Snapshot(파생 상태) 패턴 적용 (최종 방안)
- **개념:** 오직 검색어 동기화만 담당하는 `useSearch`와, 폴더/문항 선택 상태 동기화만 담당하는 `useLibrarySelectionSync`로 훅을 분리. `useEffect` 내부의 강제 렌더링을 제거하고, 렌더링 도중 파생 상태(Snapshot)를 계산하여 로딩(Skeleton)을 제어하는 방식.
- **장점:** 각 훅이 하나의 책임만 지므로 재사용성과 확장성이 극대화됨. 렌더링 전 동기화 대기 상태(`isSyncingUrl`)를 정확히 계산해 깜빡임을 원천 차단. 라우팅 충돌은 이벤트 루프(`setTimeout`) 분리로 우아하게 해결.
- **단점:** 초기에 훅 간의 역할 경계와 라이프사이클을 세밀하게 설계해야 하므로 아키텍처 설계 난이도가 높음.

## ⚖️ 비교 정리

| 항목 | 선택지 1 (컴포넌트 내 집중) | 선택지 2 (만능 Hook 통합) | 선택지 3 (관심사 분리 + Snapshot) |
|------|----------|----------|----------|
| **구현 난이도** | 낮음 (절차적 작성) | 보통 (조건문 폭발) | 높음 (React 렌더링 이해 필요) |
| **유지보수 및 확장성**| 최악 (스파게티 코드) | 낮음 (결합도 높음) | **최상 (모듈화 완료)** |
| **UX (깜빡임 제어)** | 나쁨 (Effect 지연 발생) | 보통 | **최상 (1프레임 틈 완벽 방어)** |
| **성능 (리렌더링)** | 나쁨 (Calling Effect) | 보통 | **최상 (불필요한 렌더링 0)** |

## ✅ 최종 선택
- **선택한 방안:** 선택지 3 (관심사 분리에 따른 Custom Hook 수평 분할 및 파생 상태 패턴 적용)
- **선택 이유:** 프로젝트가 고도화됨에 따라 단순 검색 페이지, 탭 전환이 있는 워크스페이스 등 페이지별 요구사항이 다각화되었습니다. 이를 하나의 로직으로 묶으면 필연적으로 기술 부채가 발생합니다. 역할을 명확히 분리함으로써 코드의 재사용성을 높였고, 무엇보다 `useEffect`에 의존하던 낡은 동기화 방식을 버리고 렌더링 중 상태를 계산(Derived State)하여 UX를 완벽하게 통제할 수 있다는 점이 프론트엔드 관점에서 가장 합리적이고 올바른 설계라고 판단했습니다.

## 📉 아쉬운 점
- **포기한 부분:** 라우팅 프레임워크(React Router)의 변경이나 브라우저 API에 독립적인 '완전 무결한 순수 상태 로직' 작성.
- **리스크:** URL Search Params와 Local Storage라는 두 가지 외부 시스템(External System)을 동시에 추적하므로, 브라우저 스토리지 접근이 차단된 특수 환경(예: 강력한 시크릿 모드)에서는 동기화가 일부 제한될 수 있습니다.

## 🔮 이후 개선 방향
- **추후 다시 고려할 사항:** 현재는 Custom Hook 레벨에서 컴포넌트 마운트 시 동기화를 수행하고 있으나, 추후 프로젝트의 규모가 더 커진다면 `Zustand`나 `Jotai` 같은 전역 상태 관리 라이브러리에 `persist` 및 `url-sync` 미들웨어를 결합하여, 로컬 컴포넌트 단이 아닌 **전역 스토어 레벨에서 URL과 Storage 동기화를 완전히 추상화**하는 아키텍처 도입을 고려해 볼 수 있습니다.
