## 들어가며

우리 팀은 자기소개서 작성자와 첨삭자가 실시간으로 협업할 수 있는 서비스를 개발하고 있습니다. 작성자가 자소서를 작성하는 동안, 첨삭자는 특정 부분을 드래그하여 피드백을 남길 수 있습니다. 이 과정에서 흥미로운 기술적 도전 과제가 발생했습니다.

**핵심 문제**

- 작성자가 텍스트를 실시간으로 수정할 수 있습니다
- 첨삭자가 동시에 특정 영역을 드래그하고 있을 수 있습니다
- 드래그 중인 영역이 작성자에 의해 수정되면, 드래그 영역도 함께 조정되어야 합니다
- 드래그 영역이 완전히 삭제되면 드래그를 취소해야 합니다

백엔드는 이미 [OT 방식](https://www.notion.so/OT-2fa14885339b80b8a072c33b3f328179?pvs=21)을 채택([OT 방식](https://www.notion.so/OT-2fa14885339b80b8a072c33b3f328179?pvs=21) )했고, 서버에는 `"저의 <c1>성장 과정을</c1> 관통하는"`와 같이 마크업 형태로 저장됩니다. 그렇다면 프론트엔드에서는 이 데이터를 어떤 구조로 관리해야 할까요?

---

## 왜 인덱스 기반이 불가피한가?

먼저 선택의 여지가 없는 부분을 명확히 해야 합니다. 백엔드가 OT 방식을 사용하고, 첨삭 등록 API는 다음과 같은 형태를 요구합니다.

```jsx
POST /api/reviews
{
  startIdx: 3,
  endIdx: 8,
  editingText: "성장 과정",
  version: 1
}

```

서버는 인덱스를 기반으로 충돌을 해결합니다. 만약 프론트엔드에서 다른 데이터 구조(예: DOM 트리, UUID 기반 등)를 사용한다면, API 요청 시점에 인덱스로 변환하는 추가 작업이 필요합니다. 이는 불필요한 복잡도를 증가시키므로, **프론트엔드도 인덱스 기반으로 데이터를 관리하는 것이 자연스럽습니다.**

하지만 "인덱스 기반"이라는 큰 틀 안에서도 여러 방식이 존재합니다. 이제부터 각 방식을 깊이 있게 살펴보겠습니다.

---

## 방식 1: 순수 인덱스 방식

### 개념

서버에서 받은 마크업을 파싱하여 순수 텍스트(plainText)와 첨삭 목록(reviews)으로 분리합니다. 각 첨삭은 시작 인덱스(start)와 끝 인덱스(end)로만 표현됩니다.

**데이터 구조**

```jsx
{
  plainText: "저의 성장 과정을 관통하는 핵심",
  reviews: [
    { id: 'c1', start: 3, end: 8, selectedText: '성장 과정' }
  ],
  selection: { start: 14, end: 16, selectedText: '핵심' }
}

```

### 작동 원리

**파싱 과정:**
서버 마크업 `"저의 <c1>성장 과정을</c1> 관통하는"`를 받으면, 정규식을 사용해 태그를 찾고 제거하면서 각 첨삭의 위치를 계산합니다. 태그의 시작 위치를 기록하고, 태그 길이만큼 오프셋을 조정하여 순수 텍스트 기준 인덱스를 산출합니다.

**렌더링:**
plainText를 reviews의 인덱스 정보를 기반으로 청크(chunk)로 나눕니다. 0~3번째는 일반 텍스트, 3~8번째는 하이라이트, 8번째 이후는 다시 일반 텍스트로 구분하여 각각 다른 스타일을 적용합니다. 이 청크 생성은 렌더링할 때마다 실시간으로 수행되며, 메모리에 영구 저장하지 않습니다.

**드래그 처리:**
사용자가 텍스트를 드래그하면 브라우저의 Selection API가 DOM 노드와 오프셋으로 위치를 알려줍니다. TreeWalker로 모든 텍스트 노드를 순회하며 누적 길이를 계산하여 전체 plainText 기준 인덱스로 변환합니다. 예를 들어 사용자가 "핵심"을 드래그하면 이것이 14~16번째 글자라는 것을 계산해냅니다.

**실시간 동기화:**
작성자가 맨 앞에 "안녕하세요. "를 추가하면, 서버는 SSE로 새로운 plainText와 재계산된 reviews를 전송합니다. 프론트엔드는 이를 받아 상태를 교체합니다. 드래그 중이었다면 기존 선택 영역의 텍스트(selectedText)와 새 위치의 텍스트를 비교하여 일치하지 않으면 드래그를 취소합니다.

### 장점

**1. 정확성과 명확성**

인덱스는 절대적 위치 정보입니다. "3번째 글자부터 8번째 글자까지"라는 정보는 누가 봐도, 어떤 시스템에서 봐도 동일한 위치를 가리킵니다. 텍스트 내용이 무엇인지는 중요하지 않으며, 오직 위치만이 중요합니다. 이는 띄어쓰기가 바뀌거나 비슷한 내용이 여러 곳에 있어도 정확히 구분할 수 있게 해줍니다. 예를 들어 "성장"이라는 단어가 자소서에 5번 나온다 해도, 인덱스로는 각각을 명확히 구분합니다.

**2. 빠른 연산 속도**

모든 주요 연산이 숫자 계산으로 이루어집니다. 겹침 체크는 네 개의 숫자를 비교하는 것입니다: `!(newEnd <= existingStart || newStart >= existingEnd)`. 이는 O(1) 시간 복잡도로 즉시 계산됩니다. 첨삭이 1000개가 있어도 각각을 순회하며 이 간단한 수식만 평가하면 되므로, 밀리초 단위로 처리됩니다. 반면 텍스트 기반 검색이라면 매번 문자열을 찾고 비교해야 하므로 훨씬 느립니다.

**3. 메모리 효율성**

각 첨삭당 두 개의 정수(start, end)만 저장하면 됩니다. 64비트 정수 두 개로 16바이트입니다. 첨삭 1000개라면 16KB에 불과합니다. 만약 각 첨삭마다 전체 텍스트와 주변 컨텍스트를 저장한다면 수백 KB가 필요할 수 있습니다. 또한 렌더링을 위한 청크는 메모리에 영구 저장하지 않고 필요할 때만 생성하므로, 실제 메모리 사용량은 더욱 작습니다.

**4. 서버 통신 효율성**

서버도 인덱스 기반이므로 API 요청이 단순합니다. 추가 변환 없이 `{ startIdx: 3, endIdx: 8 }`을 그대로 전송하면 됩니다. 서버는 이를 받아 바로 OT 처리에 사용할 수 있습니다. 역으로 서버에서 받은 인덱스도 그대로 사용하면 되므로 파싱 오버헤드가 최소화됩니다.

**5. 범위 쿼리 가능**

"10번째부터 20번째 글자 사이의 첨삭을 모두 찾아라"는 요구사항이 생기면, 간단한 범위 비교로 필터링할 수 있습니다: `reviews.filter(r => r.start >= 10 && r.end <= 20)`. 데이터베이스에서도 인덱스를 활용한 효율적인 범위 쿼리가 가능합니다. 이는 향후 기능 확장(예: 특정 문단의 첨삭만 보기)에 유리합니다.

**6. 정렬의 자연스러움**

첨삭을 start 값으로 정렬하면 자동으로 텍스트의 앞에서 뒤 순서대로 나열됩니다. 별도의 순서 관리가 필요 없고, `reviews.sort((a, b) => a.start - b.start)` 한 줄이면 끝입니다. 렌더링 시 이 순서대로 처리하면 자연스럽게 좌에서 우로 하이라이트가 그려집니다.

**7. 드래그 영역 조정의 명확성**

드래그 중인 영역도 하나의 인덱스 범위일 뿐이므로, 텍스트 수정 시 동일한 재계산 로직을 적용할 수 있습니다. 작성자가 드래그 영역 앞에 텍스트를 추가하면 start와 end 모두 증가하고, 드래그 영역 안에 추가하면 end만 증가합니다. 이 규칙은 명확하고 예외가 없어서 구현이 안정적입니다. 드래그 영역이 완전히 삭제되었는지도 단순히 `start === end` 또는 `end - start <= 0`을 체크하는 것으로 확인할 수 있습니다.

### 단점

**1. 파싱 복잡도**

서버 마크업 `"저의 <c1>성장 과정을</c1> 관통하는"`를 순수 텍스트와 인덱스로 변환하는 파싱 로직이 필요합니다. 정규식으로 태그를 찾고, 각 태그의 위치를 계산하고, 태그를 제거한 순수 텍스트를 만들어야 합니다. 중첩된 태그나 잘못된 형식을 처리하는 에러 핸들링도 고려해야 합니다. 초기 구현에 50~100줄 정도의 코드가 필요하고, 엣지 케이스를 고려하면 더 복잡해질 수 있습니다. 하지만 이는 한 번만 작성하면 재사용되는 코드입니다.

**2. 역파싱의 부담**

첨삭을 등록할 때는 반대 과정이 필요합니다. 현재 plainText와 인덱스를 가지고 있는데, 서버에 보낼 때는... 사실 이는 큰 문제가 아닙니다. 왜냐하면 API는 인덱스만 요구하기 때문입니다. 마크업 재구성은 서버가 담당합니다. 따라서 이 단점은 우리 프로젝트에서는 해당하지 않습니다.

**3. 디버깅 시 가독성**

개발 중 `{ start: 3, end: 8 }`이라는 정보만 봐서는 실제로 어떤 내용인지 바로 알 수 없습니다. 전체 plainText를 함께 보거나 selectedText를 별도로 저장해야 합니다. "어, 이 첨삭이 왜 여기 있지?"라고 의문이 들 때, 인덱스만으로는 바로 파악이 안 되고 텍스트를 직접 잘라봐야 합니다. 하지만 selectedText를 함께 저장하면 이 문제는 크게 완화됩니다.

**4. TreeWalker의 복잡성**

사용자가 드래그할 때, 브라우저의 Selection API는 DOM 노드와 오프셋으로 위치를 알려줍니다. 이를 전체 텍스트 기준 인덱스로 변환하려면 TreeWalker로 모든 텍스트 노드를 순회하며 길이를 누적해야 합니다. 이 코드는 40~50줄 정도로 비교적 복잡하고, DOM 구조가 바뀌면 영향을 받을 수 있습니다. 하지만 이 역시 한 번 작성하면 재사용되는 유틸리티 함수입니다.

---

## 방식 2: DOM 트리 구조 방식

### 개념

서버의 마크업 구조를 그대로 유지하는 방식입니다. `<c1>` 태그가 있으면 이를 "review 타입의 노드"로, 일반 텍스트는 "text 타입의 노드"로 변환해서 배열로 저장합니다.

**데이터 구조**

```jsx
{
  nodes: [
    { type: 'text', content: '저의 ' },
    { type: 'review', id: 'c1', content: '성장 과정을' },
    { type: 'text', content: ' 관통하는 핵심' }
  ]
}

```

### 작동 원리

**파싱:**
정규식으로 태그를 찾아 split하고, 태그 안의 텍스트는 review 노드로, 밖의 텍스트는 text 노드로 분류합니다. HTML의 DOM 트리 파싱과 유사한 방식입니다.

**렌더링:**
nodes 배열을 순회하면서, type이 'review'인 노드는 하이라이트 스타일을, 'text'인 노드는 일반 스타일을 적용합니다. React의 map 함수 한 번으로 간단하게 구현됩니다.

**드래그 처리:**
선택 영역의 시작과 끝이 어느 노드의 몇 번째 글자인지 찾아야 합니다. 예를 들어 첫 번째 노드의 2번째 글자부터 세 번째 노드의 5번째 글자까지 선택했다는 정보를 저장합니다.

### 장점

**1. 파싱의 단순함**

마크업을 정규식으로 태그를 기준으로 나누고, 각 부분을 노드로 만들면 됩니다. 태그 안의 텍스트는 review 노드, 밖의 텍스트는 text 노드로 분류하는 단순한 로직입니다. 30~40줄 정도의 간결한 코드로 구현 가능하고, 중첩이 없다면 엣지 케이스도 적습니다.

**2. 직관적인 데이터 구조**

개발자가 데이터를 봤을 때 바로 이해할 수 있습니다. `{ type: 'review', content: '성장 과정을' }`을 보면 "아, 이게 첨삭 부분이구나"라고 즉시 알 수 있습니다. 디버깅할 때 어떤 내용인지 바로 파악되므로 편리합니다.

**3. 렌더링의 간결함**

React에서 `nodes.map(node => ...)` 한 줄이면 전체 UI가 렌더링됩니다. 하이라이트 여부도 node.type으로 바로 판단되므로 조건문이 단순합니다. 인덱스를 계산해서 청크로 나누는 복잡한 로직이 필요 없습니다.

### 단점

**1. 겹침 체크의 비효율**

새 드래그가 기존 첨삭과 겹치는지 확인하려면, 드래그 범위에 포함된 모든 노드를 순회해야 합니다. 노드가 100개라면 최악의 경우 100번 확인해야 하므로 O(n) 시간이 걸립니다. 반면 인덱스 기반은 4개의 숫자만 비교하면 되는 O(1)입니다. 실시간 드래그 검증에서 이 차이는 체감될 수 있습니다.

**2. 범위 검색의 한계**

"10번째 글자부터 20번째 글자까지의 첨삭을 찾아라"는 요구사항이 있다면, 모든 노드를 순회하며 누적 길이를 계산해야 합니다. 데이터베이스 쿼리처럼 효율적인 범위 검색이 불가능합니다. 향후 기능 확장 시 제약이 됩니다.

**3. 드래그 영역 조정의 복잡성**

드래그가 여러 노드에 걸쳐 있을 때, 작성자가 중간 노드를 수정하면 어떻게 조정할지 결정하기 어렵습니다. 예를 들어 첫 번째 노드의 끝부분부터 세 번째 노드의 시작 부분까지 드래그했는데, 두 번째 노드가 삭제되면 드래그 범위를 어떻게 정의해야 할까요? 이런 복잡한 경우의 수를 처리하는 로직이 필요하고, 각 케이스마다 정책을 정해야 합니다.

**4. 서버 통신 시 변환 필요**

API 요청 시점에 노드 기반 위치를 인덱스로 변환해야 합니다. 드래그 시작 노드까지의 모든 노드 길이를 누적하고, 노드 내 오프셋을 더하여 전체 인덱스를 계산해야 합니다. 이는 추가 연산이며, 실수의 여지가 있습니다.

**5. 메모리 오버헤드**

각 노드가 객체이므로, 짧은 텍스트도 `{ type: 'text', content: '의 ' }` 같은 구조로 저장됩니다. 텍스트가 nodes 배열에 중복 저장되므로 메모리 사용량이 인덱스 기반보다 큽니다.

**6. 드래그 완전 삭제 감지의 복잡성**

드래그 영역이 완전히 삭제되었는지 확인하려면, 해당 노드들이 모두 없어졌는지, 또는 노드의 길이가 0이 되었는지 여러 조건을 확인해야 합니다. 노드가 병합되거나 분할되는 경우도 고려해야 해서 로직이 복잡합니다.

---

## 방식 3: 하이브리드 (인덱스 + 노드 둘 다 유지)

### 개념

인덱스 방식과 DOM 트리 방식의 장점을 모두 가져가기 위해, 두 가지 데이터 구조를 동시에 유지합니다.

**데이터 구조**

```jsx
{
  plainText: "저의 성장 과정을 관통하는 핵심",
  reviews: [
    { id: 'c1', start: 3, end: 8, selectedText: '성장 과정' }
  ],
  nodes: [
    { type: 'text', content: '저의 ' },
    { type: 'review', id: 'c1', content: '성장 과정', start: 3, end: 8 },
    { type: 'text', content: ' 관통하는 핵심' }
  ]
}

```

### 장점

**1. 양쪽 장점 활용**

빠른 검색이 필요할 때는 인덱스를 쓰고, 간단한 렌더링이 필요할 때는 nodes를 씁니다. 각 상황에 최적화된 데이터 구조를 선택할 수 있어서 이론적으로는 최고의 성능과 편의성을 얻습니다.

**2. 유연한 대응**

요구사항이 바뀌어도 두 가지 구조 중 하나는 대응 가능할 확률이 높습니다. 예를 들어 "특정 범위의 첨삭 개수"를 세는 새 기능이 추가되면 인덱스로 빠르게 구현하고, "첨삭을 순서대로 보여주기"는 nodes로 간단하게 구현합니다.

### 단점

**1. 메모리 사용량 2배**

같은 정보를 두 가지 형태로 저장하므로 메모리가 거의 2배 필요합니다. 첨삭이 1000개면 reviews 배열 1000개 + nodes 배열 1000개를 모두 유지해야 합니다. 모바일 환경에서 메모리 제약이 있다면 문제가 될 수 있습니다.

**2. 동기화의 복잡성과 버그 위험 (가장 큰 문제)**

reviews를 업데이트할 때 nodes도 함께 업데이트해야 하는데, 실수로 한쪽만 업데이트하거나 순서가 어긋나면 데이터 불일치가 발생합니다. "reviews에는 있는데 nodes에는 없다" 같은 버그가 생기면 찾기도 어렵고, 화면이 깨지거나 충돌이 발생할 수 있습니다. SSE로 업데이트를 받을 때마다 두 구조를 정확히 일치시키는 것은 상당한 주의가 필요합니다.

**3. 코드 복잡도 증가**

모든 업데이트 로직에서 두 가지를 함께 처리해야 하므로 코드가 2배 이상 복잡해집니다. 새 개발자가 코드를 이해하기 어렵고, 유지보수 비용이 큽니다. 각 함수마다 "reviews도 업데이트했나? nodes도 업데이트했나?"를 확인해야 합니다.

**4. 성능 오버헤드**

업데이트할 때마다 두 가지 데이터 구조를 모두 갱신해야 하므로, 단일 구조보다 느립니다. SSE로 변경사항을 자주 받는 환경에서는 이 오버헤드가 체감될 수 있습니다.

**5. 테스트의 어려움**

테스트를 작성할 때도 두 데이터 구조가 항상 일치하는지 확인해야 하므로, 테스트 케이스가 복잡해지고 양도 늘어납니다. 각 업데이트 로직마다 양쪽의 일관성을 검증하는 테스트가 필요합니다.

---

## 방식 4: CRDT 스타일 (각 글자에 고유 ID)

### 개념

앞서 소개한 글에서 본 CRDT 방식처럼, 각 글자에 고유한 ID를 부여하여 관리합니다.

**데이터 구조**

```jsx
{
  characters: [
    { id: '0', char: '저', pos: 0 },
    { id: '1', char: '의', pos: 1 },
    { id: '2', char: ' ', pos: 2 },
    { id: '3', char: '성', pos: 3 },
    { id: '3.5', char: '장', pos: 4 },  // 나중에 삽입된 경우
    // ...
  ],
  reviews: [
    { id: 'c1', startCharId: '3', endCharId: '4' }
  ]
}

```

### 왜 고려했는가?

CRDT는 실시간 협업 편집에서 매우 강력한 방식입니다. Google Docs의 대안으로 떠오르는 많은 서비스들이 채택하고 있으며, 특히 P2P 환경에서 서버 없이도 동기화가 가능합니다.

### 왜 채택하지 않았는가?

**1. 서버가 이미 OT 방식**

우리 백엔드는 OT를 채택했고, API는 인덱스를 요구합니다. 프론트에서 CRDT를 쓴다면 각 글자의 ID를 인덱스로 변환하는 복잡한 로직이 필요합니다. 서버와 프론트의 데이터 모델이 완전히 달라지므로 통신 시마다 변환 오버헤드가 발생합니다.

**2. 메모리 오버헤드**

각 글자마다 고유 ID를 저장해야 합니다. 1000자 자소서라면 1000개의 ID 객체가 필요합니다. 반면 인덱스 방식은 plainText 하나와 첨삭 개수만큼의 인덱스만 있으면 됩니다. 메모리 사용량이 수십 배 차이 날 수 있습니다.

**3. 구현 복잡도**

CRDT의 핵심인 충돌 해결 알고리즘(예: 두 글자가 같은 위치에 삽입될 때)을 직접 구현해야 합니다. Yjs나 Automerge 같은 라이브러리를 쓸 수도 있지만, 이들은 서버와의 통신 방식도 함께 정의하므로 우리 백엔드와 호환되지 않습니다.

**4. 오버엔지니어링**

우리 서비스는 작성자 1명 + 첨삭자 1명의 비대칭 협업입니다. 작성자만 텍스트를 수정하고, 첨삭자는 읽기만 합니다. Google Docs처럼 여러 사람이 동시에 같은 문장을 수정하는 "진짜 실시간 협업"이 아닙니다. CRDT의 강력함이 필요 없는 상황에서 복잡도만 증가시킵니다.

---

## 방식 5: 텍스트 매칭 방식

### 개념

인덱스 대신 실제 텍스트 내용과 주변 컨텍스트로 위치를 추적합니다.

**데이터 구조**

```jsx
{
  reviews: [
    {
      id: 'c1',
      selectedText: '성장 과정을',
      contextBefore: '저의 ',
      contextAfter: ' 관통하는'
    }
  ]
}

```

### 장점

**1. 인간 친화적**

디버깅할 때 어떤 내용인지 바로 알 수 있습니다. 인덱스처럼 숫자를 계산할 필요가 없습니다.

**2. 일부 재배치에 강건함**

문단 순서가 바뀌어도 텍스트와 컨텍스트가 일치하면 찾을 수 있습니다.

### 단점

**1. 중복 텍스트 문제**

"성장"이라는 단어가 자소서에 5번 나오면 어떻게 구분할까요? contextBefore와 contextAfter를 함께 사용해도, 비슷한 문맥이 여러 곳에 있으면 모호합니다.

**2. 텍스트 수정 시 찾기 실패**

작성자가 "성장 과정을" → "성장과 발전의 과정을"로 수정하면, 원본 텍스트로는 더 이상 찾을 수 없습니다. 유사도 알고리즘(Levenshtein distance 등)을 써서 "비슷한" 텍스트를 찾을 수 있지만, 정확도가 떨어지고 복잡합니다.

**3. 성능 이슈**

매번 전체 텍스트를 검색해야 하므로 O(n*m) 시간이 걸립니다(n: 텍스트 길이, m: 첨삭 개수). 인덱스 비교는 O(1)인데 비해 매우 느립니다.

**4. 서버 불일치**

서버는 인덱스를 요구하므로, 텍스트를 찾은 후 그 위치를 인덱스로 변환해야 합니다. 이는 추가 연산이며, 찾기에 실패하면 에러 처리도 복잡합니다.

---

## 우리 프로젝트의 요구사항 재확인

최종 결정을 내리기 전에, 우리 프로젝트의 핵심 요구사항을 다시 정리하겠습니다:

**1. 드래그 중 실시간 영역 조정**

- 첨삭자가 "성장 과정"을 드래그 중
- 작성자가 앞에 "빠른 "을 삽입
- 드래그 영역이 "성장 과정"을 계속 가리켜야 함

**2. 드래그 영역 완전 삭제 감지**

- 작성자가 드래그된 부분을 모두 삭제
- 드래그가 자동 취소되어야 함

**3. 겹침 체크**

- 새 첨삭이 기존 첨삭과 겹치는지 즉시 판단
- 빠른 피드백 필요

**4. SSE 실시간 동기화**

- 작성자 타이핑할 때마다 (배치 처리 후) 업데이트
- 첨삭자 화면에 즉시 반영

**5. 서버 통신**

- API는 인덱스 기반
- 서버도 인덱스로 OT 처리

---

## 최종 결정: 순수 인덱스 방식

여러 방식을 검토한 결과, 우리 팀은 **순수 인덱스 방식**을 선택했습니다.

### 결정 이유

**1. 요구사항과의 완벽한 정합성**

우리의 가장 까다로운 요구사항은 "드래그 중 텍스트 수정 시 드래그 영역 자동 조정"과 "완전 삭제 감지"입니다. 인덱스 방식은 이를 가장 정확하고 간단하게 처리합니다. 서버에서 "어디에 무엇이 추가/삭제되었다"는 정보만 주면, 기계적인 산술 연산으로 모든 인덱스를 조정할 수 있습니다. 드래그 영역이 모두 지워졌는지는 `start === end` 하나로 끝납니다.

**2. 서버 아키텍처와의 일치**

백엔드가 OT + 인덱스 기반이므로, 프론트도 인덱스 기반을 쓰면 통신이 자연스럽습니다. API 요청 시 추가 변환 없이 `{ startIdx, endIdx }`를 그대로 전송하고, 서버 응답도 그대로 사용합니다. 데이터 모델이 일치하면 버그가 줄고 유지보수가 쉽습니다.

**3. 성능**

겹침 체크, 범위 검색, 정렬 등 모든 주요 연산이 O(1) 또는 O(n log n)으로 빠릅니다. 첨삭이 많아져도 성능 저하가 거의 없습니다. 실시간 드래그 검증에서 이는 중요합니다.

**4. 단점의 관리 가능성**

파싱 복잡도와 TreeWalker는 초기 투자일 뿐이고, 한 번 작성하면 거의 수정할 일이 없습니다. 디버깅 가독성은 selectedText를 함께 저장하면 해결됩니다.

### 다른 방식을 배제한 이유

**DOM 트리:**

- 겹침 체크가 O(n)으로 느림
- 드래그 조정 로직이 복잡하고 불명확
- 서버 통신 시 인덱스 변환 필요

**하이브리드:**

- 동기화 복잡도가 너무 큼
- 메모리 2배, 코드 복잡도 2배
- 얻는 이득 대비 비용이 과함

**CRDT:**

- 서버가 OT이므로 변환 오버헤드
- 메모리 과다 사용
- 우리 유스케이스에 오버엔지니어링

**텍스트 매칭:**

- 중복 텍스트 구분 불가
- 성능 이슈
- 서버 통신 복잡

---

## 구현 상세

### 최종 데이터 구조

```jsx

{
  plainText: "저의 성장 과정을 관통하는 핵심",
  reviews: [
    {
      id: 'c1',
      startIdx: 3,
      endIdx: 8,
      selectedText: '성장 과정',  // 디버깅용
      revision: '성장과 발전의 과정',
      comment: '좀 더 구체적으로'
    }
  ],
  version: 5
}

{
  selection: {
    startIdx: 14,
    endIdx: 16,
    selectedText: '핵심'
  } | null,
  editingReview: Review | null
}

```

### 핵심 함수들

**1. 마크업 파싱:**

```
입력: "저의 <c1>성장 과정을</c1> 관통하는"
출력: {
  plainText: "저의 성장 과정을 관통하는",
  reviews: [{ id: 'c1', startIdx: 3, endIdx: 8 }]
}

```

**2. 청크 생성 (렌더링용):**

```
입력: plainText + reviews
출력: [
  { text: '저의 ', isHighlighted: false },
  { text: '성장 과정을', isHighlighted: true },
  { text: ' 관통하는', isHighlighted: false }
]

```

**3. 드래그 인덱스 계산:**

```
입력: DOM Selection
출력: { startIdx: 14, endIdx: 16, selectedText: '핵심' }

```

**4. 겹침 체크:**

```
입력: newSelection + existingReviews
출력: boolean (겹치는가?)
로직: !(newEnd <= existingStart || newStart >= existingEnd)

```

---

## 결론

우리는 실시간 협업 자소서 첨삭 서비스를 개발하면서, 프론트엔드 데이터 구조를 선택하는 과정에서 다양한 방식을 검토했습니다. DOM 트리, 하이브리드, CRDT, 텍스트 매칭 등 각 방식은 나름의 장단점이 있었지만, 최종적으로 **순수 인덱스 방식**을 선택했습니다.

이 결정의 핵심은 세 가지였습니다:

1. **서버 아키텍처와의 정합성**: 백엔드가 OT + 인덱스 기반이므로, 프론트도 인덱스 기반을 쓰면 통신이 자연스럽고 변환 오버헤드가 없습니다.
2. **요구사항과의 완벽한 부합**: 드래그 영역 자동 조정, 완전 삭제 감지, 겹침 체크 등 우리의 핵심 기능을 가장 정확하고 효율적으로 구현할 수 있었습니다.
3. **성능과 메모리 효율**: 모든 주요 연산이 빠르고, 메모리 사용량이 최소화됩니다.

물론 파싱 복잡도와 TreeWalker 구현이라는 초기 투자 비용이 있었지만, 이는 한 번만 작성하면 재사용되는 코드였고, 장기적으로 보면 충분히 감당할 만한 복잡도였습니다.

이 글이 비슷한 실시간 협업 기능을 구현하는 다른 개발자들에게 도움이 되기를 바랍니다. 기술 선택은 정답이 없으며, 각 프로젝트의 요구사항과 제약사항에 따라 최선의 선택이 달라진다는 것을 다시 한번 느꼈습니다.

---

## 참고자료

- [[CRDT 구현하기 - CRDT란?](https://hbsps.tistory.com/entry/CRDT-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-CRDT%EB%9E%80)](https://hbsps.tistory.com/entry/CRDT-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-CRDT%EB%9E%80)
- [[Channel - CRDT vs OT](https://channel.io/ko/blog/crdt_vs_ot)](https://channel.io/ko/blog/crdt_vs_ot)
- Google Docs, Notion(Notion API), Figma 사이트 네트워크 탭을 통해 통신 구조 확인