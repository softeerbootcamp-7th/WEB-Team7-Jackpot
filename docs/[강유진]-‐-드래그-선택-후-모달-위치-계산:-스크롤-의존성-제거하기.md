## 들어가며

자기소개서 첨삭 시스템에서 사용자가 텍스트를 드래그하면 해당 위치에 첨삭 모달이 표시되는 기능을 구현하게 되었습니다. 요구사항은 다음과 같았습니다:

- 텍스트 드래그 시 선택 영역의 첫 줄이 컨테이너 최상단으로 스크롤
- 스크롤 후 선택 영역 바로 아래에 첨삭 모달 표시
- 부드러운 애니메이션(`behavior: 'smooth'`)으로 자연스러운 UX 제공

겉보기엔 단순해 보였지만, 이 기능은 예상치 못한 딜레마를 안고 있었습니다.

## 초기 구현: setTimeout의 딜레마

### 스크롤 완료를 기다려야 하는 이유

처음 구현할 때의 접근 방식은 직관적이었습니다.

1. 사용자가 텍스트 드래그
2. 스크롤 애니메이션 시작
3. **스크롤 완료 대기** ⏳
4. 모달 위치 계산 및 표시

```jsx
const handleMouseUp = useCallback(() => {
  const sel = window.getSelection();
  const range = sel.getRangeAt(0);
  const { start, end } = rangeToTextIndices(containerRef.current, range);

  // 스크롤 실행
  const rects = range.getClientRects();
  const firstRect = rects[0];
  const containerRect = containerRef.current.getBoundingClientRect();
  const offset = firstRect.top - containerRect.top;
  const desiredScrollTop = containerRef.current.scrollTop + offset;

  containerRef.current.scrollTo({
    top: Math.max(0, Math.floor(desiredScrollTop)),
    behavior: 'smooth', // 부드러운 애니메이션
  });

  // ❓ 얼마나 기다려야 할까?
  setTimeout(() => {
    const modalInfo = calculateModalInfo(
      containerRef.current!,
      range,
      sel.toString(),
    );
    if (modalInfo) onSelectionChange(modalInfo);
  }, ???); // 여기에 어떤 값을 넣어야 할까?
}, [reviews, onSelectionChange]);

```

**핵심 문제:** Range 객체의 `getClientRects()`는 Range 생성 시점의 DOM 위치를 기억합니다. 스크롤이 일어나도 이 좌표는 업데이트되지 않습니다. 따라서 **스크롤이 완료된 후**에 모달 위치를 계산해야 정확한 위치를 얻을 수 있습니다.

### setTimeout 값 설정의 불가능성

실제로 테스트하면서 여러 값을 시도해봤습니다:

```jsx
// 시도 1: 300ms
setTimeout(() => { /* ... */ }, 300);
// 문제: 긴 스크롤(문서 하단 → 상단)에서는 부족

// 시도 2: 500ms
setTimeout(() => { /* ... */ }, 500);
// 문제: 짧은 스크롤에서는 불필요한 대기

// 시도 3: 1000ms
setTimeout(() => { /* ... */ }, 1000);
// 문제: 사용자 경험 저하 (너무 느림)

```

**실제로 겪은 문제들**

1. **짧은 스크롤**: 2-3줄만 이동할 때는 100ms면 충분한데 1초를 기다림 → UX 저하
2. **긴 스크롤**: 긴 문서에서 상단으로 스크롤할 때 1초로는 부족 → 모달이 엉뚱한 위치에 표시
3. **기기 성능**: 느린 기기에서는 동일한 스크롤도 더 오래 걸림 → 일관성 없는 동작
4. **예측 불가능**: 사용자가 얼마나 긴 문서를 작성할지 알 수 없음

```jsx
// 최악의 시나리오
// - 5000자 자기소개서
// - 하단에서 상단으로 드래그
// - 스크롤 거리: ~3000px
// - 실제 완료 시간: 1.5초
// - 설정한 timeout: 1초
// → 스크롤 도중에 모달 위치 계산 → 틀린 위치!

```

### 스크롤 완료 이벤트의 부재

"그럼 스크롤 완료 이벤트를 감지하면 되지 않을까?"라고 생각할 수 있지만, `scroll` 이벤트는 스크롤이 진행되는 동안 계속 발생하며, 정확한 "완료" 시점을 알려주지 않습니다.

```jsx
// ❌ 이런 방법도 불완전
containerRef.current.addEventListener('scroll', () => {
  clearTimeout(timer);
  timer = setTimeout(() => {
    // 스크롤이 멈췄다고 가정
  }, 100);
});
// 문제: smooth 스크롤은 이미 예약된 애니메이션
// scroll 이벤트로는 애니메이션 완료를 정확히 알 수 없음

```

## 문제의 본질: 왜 스크롤을 기다려야만 했는가?

### Range 객체의 한계

```jsx
// 스크롤 전: Range 생성
const range = sel.getRangeAt(0);
const rects = range.getClientRects();
const lastLineRect = rects[rects.length - 1];

console.log(lastLineRect.bottom); // 예: 800px (뷰포트 기준)

// 스크롤 실행...

// 스크롤 후: 같은 Range 객체 사용
const rectsAfter = range.getClientRects();
const lastLineRectAfter = rectsAfter[rectsAfter.length - 1];

console.log(lastLineRectAfter.bottom); // 여전히 800px!
// ❌ Range는 생성 시점의 좌표를 기억하며 업데이트되지 않음

```

**시각화:**

```
스크롤 전:
┌─────────────────┐ container top: 100px
│   [보이는 영역]  │
│                 │
│   선택 영역      │ ← range 생성 (lastRect.bottom: 800px)
│   ■■■■■■■      │
│                 │
└─────────────────┘

스크롤 후 (실제 DOM):
┌─────────────────┐ container top: 100px
│   선택 영역      │ ← 실제 위치 (lastRect.bottom: 150px)
│   ■■■■■■■      │
│                 │
│   [여기 모달]    │ ← 모달이 표시되어야 할 곳
└─────────────────┘

range.getClientRects() (스크롤 후에도):
여전히 800px 반환! ← 이것이 문제의 핵심

```

### 왜 editingReview는 작동했나?

기존 첨삭 수정 기능은 잘 작동했습니다. 차이점을 분석해봤습니다:

```jsx
// editingReview: 스크롤 후 Range를 새로 생성
useEffect(() => {
  const { range, selectedText } = editingReview;

  // 1. 텍스트 인덱스로부터 DOM 노드 찾기
  const startPos = findNodeAtIndex(containerRef.current, range.start);
  const endPos = findNodeAtIndex(containerRef.current, range.end);

  // 2. 스크롤 전 Range 생성
  const domRange = document.createRange();
  domRange.setStart(startPos.node, startPos.offset);
  domRange.setEnd(endPos.node, endPos.offset);

  // 3. 스크롤 실행
  containerRef.current.scrollTo({ /* ... */ });

  // 4. 스크롤 후 모달 위치 계산
  setTimeout(() => {
    // ✅ 이때 domRange.getClientRects()는
    // 스크롤 후의 DOM 위치를 반영!
    const modalInfo = calculateModalInfo(
      containerRef.current!,
      domRange,
      selectedText,
    );
    if (modalInfo) onSelectionChange(modalInfo);
  }, 1000);
}, [editingReview]);

```

**왜 작동했는가?**

Range를 스크롤 **전**에 생성했고, `calculateModalInfo`는 스크롤 **후**에 호출되었습니다. 이 사이에 브라우저가 레이아웃을 재계산했기 때문에 `getClientRects()`가 업데이트된 위치를 반환했습니다.

**하지만 여전히 문제:**
여전히 setTimeout에 의존하고 있으며, 적절한 대기 시간을 설정할 수 없다는 근본적 문제는 해결되지 않았습니다.

## 핵심 인사이트: 무엇을 미리 계산할 수 있는가?

문제를 다시 정의했습니다:

**우리가 원하는 것:**

- 스크롤 후 모달이 표시될 Y 좌표

**우리가 알고 있는 것 (스크롤 전):**

- 선택 영역의 첫 줄 위치 (`firstRect.top`)
- 선택 영역의 마지막 줄 위치 (`lastLineRect.bottom`)
- 컨테이너의 현재 위치 (`containerRect.top`)
- 스크롤할 거리 (`offset`)

**핵심 질문:**
스크롤이 완료되면 첫 줄이 컨테이너 최상단에 위치할 것입니다. 그렇다면 선택 영역의 **높이**를 알면 모달 위치를 미리 계산할 수 있지 않을까?

### 불변 속성 vs 가변 속성

```jsx
// 가변 속성 (스크롤에 따라 변함)
firstRect.top       // 300px → 100px (스크롤 후)
lastLineRect.bottom // 350px → 150px (스크롤 후)

// 불변 속성 (스크롤과 무관)
선택 영역의 높이 = lastLineRect.bottom - firstRect.top
                = 350 - 300 = 50px (항상 동일!)

```

**발견:**
선택 영역의 높이는 스크롤과 무관합니다! 이 값으로 스크롤 후 위치를 예측할 수 있습니다.

## 최종 해결: 스크롤 독립적 계산

```jsx
const handleMouseUp = useCallback(() => {
  const sel = window.getSelection();
  if (!sel || sel.isCollapsed || !containerRef.current) return;

  const range = sel.getRangeAt(0);
  if (!containerRef.current.contains(range.commonAncestorContainer)) return;

  const { start, end } = rangeToTextIndices(containerRef.current, range);

  if (isRangeOverlapping(start, end, reviews.map((r) => r.range))) {
    sel.removeAllRanges();
    alert('이미 첨삭이 등록된 영역입니다.');
    return;
  }

  const selectedText = sel.toString();
  const rects = range.getClientRects();

  if (rects.length > 0) {
    const firstRect = rects[0];
    const lastLineRect = rects[rects.length - 1];
    const containerRect = containerRef.current.getBoundingClientRect();

    // ⭐ 핵심 1: 스크롤 전에 필요한 모든 정보 계산

    // lineEndIndex는 현재 위치 기준으로 계산
    const lineEndIndex = findLineEndIndex(
      containerRef.current,
      end,
      lastLineRect.bottom
    );

    // 스크롤 거리 계산
    const offset = firstRect.top - containerRect.top;
    const desiredScrollTop = containerRef.current.scrollTop + offset;

    // ⭐ 핵심 2: 선택 영역의 높이 (불변 속성)
    const selectionHeight = lastLineRect.bottom - firstRect.top;

    // ⭐ 핵심 3: 스크롤 후 모달 위치 예측
    // 스크롤 후: firstRect.top === containerRect.top
    // 따라서: 모달 위치 = containerRect.top + selectionHeight + PADDING
    const PADDING = 10;
    const modalTop = containerRect.top + selectionHeight + PADDING;
    const modalLeft = lastLineRect.left;

    // 스크롤 실행
    containerRef.current.style.overflowY = 'auto';
    containerRef.current.scrollTo({
      top: Math.max(0, Math.floor(desiredScrollTop)),
      behavior: 'smooth',
    });

    // ⭐ 핵심 4: 스크롤 완료를 기다릴 필요 없음!
    // 이미 계산된 값을 바로 사용
    setTimeout(() => {
      containerRef.current?.style.removeProperty('overflowY');
      onSelectionChange({
        selectedText,
        range: { start, end },
        modalTop,        // 스크롤과 독립적으로 계산된 값
        modalLeft,       // 스크롤과 독립적으로 계산된 값
        lineEndIndex,
      });
    }, 300); // 이제 이 값은 스크롤 완료 대기가 아닌
             // overflowY 속성 복원 타이밍용
  } else {
    const modalInfo = calculateModalInfo(
      containerRef.current,
      range,
      selectedText,
    );
    if (modalInfo) onSelectionChange(modalInfo);
  }
}, [reviews, onSelectionChange]);

```

### 작동 원리 상세 설명

### 1단계: 선택 영역 높이 계산

```jsx
const selectionHeight = lastLineRect.bottom - firstRect.top;
// 예: 350 - 300 = 50px

// 이 값은 스크롤과 무관하게 항상 동일
// 왜냐하면 선택된 텍스트 자체의 물리적 높이이기 때문

```

### 2단계: 스크롤 후 예상 위치 계산

```jsx
// 스크롤의 목적: firstRect.top을 containerRect.top으로 이동
//
// 스크롤 전:
// containerRect.top: 100px
// firstRect.top: 300px
//
// 스크롤 후:
// containerRect.top: 100px (불변)
// firstRect.top: 100px (스크롤로 이동됨)
//
// 따라서 선택 영역의 끝:
// modalTop = containerRect.top + selectionHeight
//          = 100 + 50 = 150px

```

### 3단계: 즉시 사용 가능

```jsx
// 스크롤 완료를 기다릴 필요 없음!
onSelectionChange({
  selectedText,
  range: { start, end },
  modalTop,      // 이미 정확한 값
  modalLeft,
  lineEndIndex,
});

```

### 시각적 검증

```
스크롤 전 측정:
┌─────────────────┐ ← containerRect.top = 100px
│   [보이는 영역]  │
│                 │
│   ──────────    │ ← firstRect.top = 300px
│   선택 영역      │
│   ■■■■■■■      │ ← lastLineRect.bottom = 350px
│                 │
│                 │   selectionHeight = 350 - 300 = 50px
└─────────────────┘

스크롤 후 예측:
┌─────────────────┐ ← containerRect.top = 100px (불변)
│   ──────────    │ ← firstRect (여기로 이동) = 100px
│   선택 영역      │
│   ■■■■■■■      │ ← 끝 위치 = 100 + 50 = 150px
│                 │
│   [모달 위치]    │ ← modalTop = 150 + 10 = 160px ✅
│                 │
└─────────────────┘

실제 스크롤 후 (검증):
브라우저가 레이아웃 재계산 완료
firstRect.top = 100px ✅
lastLineRect.bottom = 150px ✅
modalTop = 160px ✅ (정확히 일치!)

```

## Before vs After: 극명한 차이

### Before: 스크롤 대기 방식

```jsx
// ❌ 문제점들:

// 1. 불확실한 대기 시간
setTimeout(() => { /* ... */ }, 1000); // 왜 1000ms?

// 2. 짧은 스크롤에서 불필요한 지연
// - 2줄 스크롤: 100ms면 충분 → 1000ms 대기 → UX 저하

// 3. 긴 스크롤에서 틀린 계산
// - 5000px 스크롤: 1500ms 필요 → 1000ms에 계산 → 틀린 위치

// 4. 기기 성능 의존성
// - 느린 기기: 동일 스크롤도 더 오래 걸림 → 일관성 없음

// 5. 예측 불가능성
// - 사용자가 얼마나 긴 문서를 쓸지 모름
// - 드래그 위치에 따라 스크롤 거리 가변

```

### After: 스크롤 독립 방식

```jsx
// ✅ 장점들:

// 1. 즉시 계산 가능
const selectionHeight = lastLineRect.bottom - firstRect.top;
const modalTop = containerRect.top + selectionHeight + PADDING;
// 스크롤 시작 전 이미 최종 위치를 알고 있음

// 2. 스크롤 길이와 무관
// - 짧은 스크롤: 정확 ✅
// - 긴 스크롤: 정확 ✅
// - 스크롤 완료 대기 불필요 ✅

// 3. 기기 성능 독립적
// - 모든 기기에서 동일하게 작동 ✅

// 4. 예측 가능
// - 수학적으로 계산 가능한 값
// - 디버깅 용이

```

## 성능 및 UX 개선

### 체감 성능

```jsx
// Before:
// 사용자 드래그 → 스크롤 시작 → ... 1초 대기 ... → 모달 표시
// 짧은 스크롤: ████░░░░░░░░░░ (불필요한 대기)
// 긴 스크롤:   ████████████░░ (스크롤 미완료 시 틀린 위치)

// After:
// 사용자 드래그 → 스크롤 시작 → 즉시 모달 표시
// 짧은 스크롤: ████▓ (거의 즉시)
// 긴 스크롤:   ████████▓ (스크롤과 동시에 모달 이동)

```

### 실제 테스트 결과

```
테스트 시나리오 1: 2줄 선택
- 스크롤 거리: ~100px
- Before: 1000ms 대기
- After: 즉시 표시
- 개선: 900ms 빨라짐 ✨

테스트 시나리오 2: 상단 ↔ 하단
- 스크롤 거리: ~3000px
- Before: 1000ms에 계산 → 틀린 위치 (스크롤 진행 중)
- After: 정확한 위치에 즉시 표시
- 개선: 정확도 100% ✨

테스트 시나리오 3: 느린 기기
- Before: 일관성 없음 (기기마다 다름)
- After: 모든 기기에서 동일하게 작동
- 개선: 일관성 확보 ✨

```

## 핵심 학습 포인트

### 1. 비동기 작업에 의존하지 않기

```jsx
// 나쁜 패턴: "완료되었으면 좋겠다"
doAsyncTask();
setTimeout(() => {
  // 완료되었기를 희망...
}, RANDOM_NUMBER);

// 좋은 패턴: "필요한 것을 미리 계산"
const predictedResult = calculateFromCurrentState();
doAsyncTask(); // 이제 기다릴 필요 없음
useResult(predictedResult);

```

### 2. 불변 속성 찾기

어떤 문제든 **변하지 않는 것**을 찾으면 예측이 가능해집니다:

- 스크롤과 무관한 값: 높이, 너비
- 상대적 관계: A와 B 사이의 거리
- 논리적 불변: 첫 줄은 항상 컨테이너 상단으로 이동

### 3. 좌표계 변환 이해

```jsx
// 절대 좌표 (뷰포트 기준)
firstRect.top = 300px

// 상대 거리 (불변)
selectionHeight = 50px

// 변환 공식
// 스크롤 후 절대 좌표 = 새로운 기준점 + 상대 거리
modalTop = containerRect.top + selectionHeight

```

### 4. 문제를 재정의하기

```jsx
// 잘못된 문제 정의:
// "스크롤이 완료되었는지 어떻게 알 수 있을까?"

// 올바른 문제 정의:
// "스크롤 완료를 기다리지 않고 최종 위치를 계산할 수 있을까?"

```

## 마치며

### 핵심 요약

1. **문제:** setTimeout으로 스크롤 완료를 기다렸지만, 적절한 대기 시간 설정이 불가능
    - 짧은 스크롤: 불필요한 지연으로 UX 저하
    - 긴 스크롤: 완료 전 계산으로 틀린 위치
    - 기기마다 다른 성능으로 일관성 부족
2. **핵심 인사이트:** 선택 영역의 높이는 스크롤과 무관한 불변 속성
3. **해결:** 상대적 높이로 스크롤 후 절대 위치 예측
    
    ```jsx
    modalTop = containerRect.top + selectionHeight + PADDING
    
    ```
    
4. **결과:**
    - 스크롤 길이와 무관하게 정확한 위치
    - 즉시 계산 가능하여 UX 개선
    - 모든 기기에서 일관된 동작

### 더 나은 개발자가 되기 위해

- **"언제 완료되나?"** 대신 **"지금 무엇을 알 수 있나?"** 질문하기
- **비동기 작업의 의존성** 최소화하기
- **불변 속성** 찾아서 예측 가능한 코드 작성하기
- **문제를 재정의**하면 더 나은 해결책이 보임

이번 경험을 통해 "일단 되게 만들기"를 넘어서, 근본적인 제약을 파악하고 그것을 제거하는 접근의 중요성을 배웠습니다.

### 참고 자료

- [[MDN - Range](https://developer.mozilla.org/en-US/docs/Web/API/Range)](https://developer.mozilla.org/en-US/docs/Web/API/Range)
- [[MDN - Element.getBoundingClientRect()](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)
- [[MDN - Element.scrollTo()](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo)](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo)
- [[CSSOM View Module](https://drafts.csswg.org/cssom-view/)](https://drafts.csswg.org/cssom-view/)