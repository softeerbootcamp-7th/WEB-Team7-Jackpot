<h1>무한 스크롤(커서 기반) 페이지네이션 구현 방식 비교</h1>
<h2>0. 개요</h2>
<p>무한 스크롤에서 흔히 사용하는 페이지네이션 방식은 크게 두 가지가 있다.</p>
<ul>
<li><strong>Offset Pagination</strong>: <code>page=3</code> 같은 페이지 번호 기반 (<code>OFFSET + LIMIT</code>)</li>
<li><strong>Keyset Pagination (Cursor Pagination)</strong>: 마지막으로 본 데이터의 커서를 기반 (<code>WHERE &lt; cursor</code>)</li>
</ul>
<p>본 문서에서는 “클라이언트가 lastId를 보내는 커서 기반”이라는 공통 조건 하에, 서버 구현 방식이 다른 두 가지 패턴을 비교한다.</p>
<p>공통 조건:</p>
<ul>
<li>
<p>클라이언트는 <strong>lastId만</strong> 전달한다.</p>
</li>
<li>
<p>createdAt / modifiedAt은 중복되지 않는다고 가정한다.</p>
<p>(※ 일반적으로는 타임스탬프 동률 문제 때문에 <code>createdAt, id</code>를 함께 쓰는 것을 권장하지만, 본 문서에서는 제외)</p>
</li>
</ul>
<hr>
<h2>1. 서브쿼리(Subquery) 기반 단일 쿼리 방식</h2>
<h3>1.1. 개념</h3>
<p>서비스 레이어에서 lastId를 받은 뒤, <strong>JPQL 쿼리 1번</strong>으로 커서 이후 데이터를 조회한다.</p>
<p>예시:</p>
<pre><code class="language-sql">SELECT nFROM Notification nWHERE n.userId= :userIdAND n.createdAt&lt; (SELECT n2.createdAtFROM Notification n2WHERE n2.id= :lastNotificationId
)ORDERBY n.createdAtDESC, n.idDESC
</code></pre>
<p>즉,</p>
<ul>
<li>lastId에 해당하는 row의 createdAt을 서브쿼리로 조회하고</li>
<li>그 값보다 작은 데이터들을 내려준다.</li>
</ul>
<hr>
<h3>1.2. 서비스 코드 특징</h3>
<ul>
<li>보통 <code>size+1</code>개를 조회한 뒤</li>
<li><code>hasNext</code>를 직접 계산하고</li>
<li>size만큼 잘라서 반환한다.</li>
</ul>
<p>예:</p>
<ul>
<li><code>fetchLimit = size + 1</code></li>
<li><code>hasNext = notifications.size() &gt;= fetchLimit</code></li>
<li><code>notifications.stream().limit(size)</code></li>
</ul>
<hr>
<h3>1.3. 장점</h3>
<h3>(1) DB 요청이 1번이다</h3>
<ul>
<li>lastId의 createdAt을 얻는 과정까지 <strong>쿼리 1번으로 처리</strong>한다.</li>
</ul>
<h3>(2) 단일 쿼리로 페이징 로직이 끝난다</h3>
<ul>
<li>“조회 로직이 레포지토리에 모인다”는 장점이 있다.</li>
</ul>
<h3>(3) 커서 기반(keyset) 형태로 구현 가능</h3>
<ul>
<li>offset 기반이 아니라 커서 기반이므로, 대규모 데이터에서도 안정적인 성능을 기대할 수 있다.</li>
</ul>
<hr>
<h3>1.4. 단점 및 리스크</h3>
<h3>(1) 서브쿼리 최적화 / 인덱스 활용이 DB에 의존한다</h3>
<ul>
<li>DB가 항상 서브쿼리를 효율적으로 처리해준다는 보장이 없다.</li>
<li>특히 조건이 복잡해지면 옵티마이저가 기대대로 동작하지 않을 가능성이 있다.</li>
</ul>
<h3>(2) lastId가 잘못되었을 때 처리가 애매하다</h3>
<ul>
<li>lastId가 삭제되었거나 존재하지 않는 경우
<ul>
<li>서브쿼리가 NULL이 되어 결과가 비정상적으로 나오거나</li>
<li>예외 처리가 어려워질 수 있다.</li>
</ul>
</li>
<li>즉, “잘못된 lastId”를 명확하게 잡기 어렵다.</li>
</ul>
<h3>(3) hasNext 계산 로직이 서비스에 남는다</h3>
<ul>
<li>일반적으로 <code>size+1</code> 조회 후 잘라내는 로직이 서비스에 존재하게 된다.</li>
<li>이는 비즈니스 로직이라기보다 “페이징 잡일”이 서비스에 섞이는 형태가 된다.</li>
</ul>
<blockquote>
<p>단, 반환 타입을 <code>List</code>가 아니라 <code>Slice</code>로 바꾸면</p>
<p>hasNext 계산을 Spring Data가 내부에서 처리할 수 있다.</p>
<p>(하지만 DB에서 size+1 조회 자체는 동일)</p>
</blockquote>
<hr>

<h2>2. 애플리케이션 로직 분리(2단계 조회) 방식</h2>
<h3>2.1. 개념</h3>
<p>서비스 레이어에서 두 단계로 처리한다.</p>
<ol>
<li>lastId로 엔티티를 조회해서 (PK 조회)</li>
<li>그 엔티티의 modifiedAt(createdAt)을 얻고</li>
<li>modifiedAt을 커서로 해서 목록을 조회한다.</li>
</ol>
<p>예:</p>
<ul>
<li>Step1: <code>SELECT modifiedAt FROM QnA WHERE id = :lastId</code></li>
<li>Step2: <code>SELECT ... FROM QnA WHERE modifiedAt &lt; :lastModifiedAt ORDER BY modifiedAt DESC LIMIT size+1</code></li>
</ul>
<hr>
<h3>2.2. 장점</h3>
<h3>(1) lastId 검증이 명확하다</h3>
<ul>
<li>lastId로 엔티티를 먼저 조회하기 때문에,
<ul>
<li>존재하지 않으면 즉시 예외 처리 가능</li>
<li>클라이언트 오류를 빠르게 판별 가능</li>
</ul>
</li>
</ul>
<h3>(2) 쿼리가 단순하고 인덱스 최적화가 쉬움</h3>
<ul>
<li>실제 목록 조회 쿼리는 다음 형태로 단순해진다:</li>
</ul>
<pre><code class="language-sql">WHERE userId= ?AND category= ?AND modifiedAt&lt; ?ORDERBY modifiedAtDESC
LIMIT ?
</code></pre>
<p>이 경우 복합 인덱스를 만들면 Range Scan으로 매우 안정적으로 동작한다.</p>
<p>추천 인덱스 예시:</p>
<ul>
<li><code>(user_id, category, modified_at DESC)</code></li>
</ul>
<h3>(3) 서비스 코드에서 확장성이 좋다</h3>
<p>예를 들어 아래 요구사항이 추가되면:</p>
<ul>
<li>“정지된 사용자의 글 제외”</li>
<li>“특정 상태(status)만 조회”</li>
<li>“필터 조건 추가”</li>
</ul>
<p>2번 방식은:</p>
<ul>
<li>lastId 조회는 그대로 유지하고</li>
<li>2단계 목록 조회 쿼리만 수정하면 된다.</li>
</ul>
<h3>(4) Slice 기반 반환을 사용하기 쉬움</h3>
<ul>
<li>Spring Data JPA에서 <code>Slice&lt;T&gt;</code>를 사용하면
<ul>
<li>hasNext 판단을 내부적으로 처리한다.</li>
</ul>
</li>
<li>서비스 코드가 비즈니스 로직에 더 집중 가능하다.</li>
</ul>
<hr>
<h3>2.3. 단점</h3>
<h3>(1) DB 쿼리가 2번 발생한다</h3>
<ul>
<li>PK 조회 1회 + 목록 조회 1회</li>
</ul>
<p>다만 PK 조회는 매우 빠른 연산이며,</p>
<p>대부분의 실제 시스템에서는 큰 부담이 되지 않는다.</p>
<h3>(2) 인덱스가 없으면 성능이 나쁠 수 있다</h3>
<ul>
<li>
<p><code>WHERE modifiedAt &lt; ?</code> 조건이 인덱스를 못 타면</p>
<p>full scan으로 이어질 수 있다.</p>
</li>
<li>
<p>따라서 인덱스 설계가 필수다.</p>
</li>
</ul>
<hr>

<h2>3. “Slice는 offset 기반인가?" 정리</h2>
<p>코드리뷰 중 팀원이 제기한 의문 + 헷갈린 부분 정리:</p>
<blockquote>
<p>“Slice는 내부적으로 offset + limit 방식이다.</p>
<p>offset이 커지면 불필요한 탐색 비용이 발생한다.</p>
<p>keyset pagination이 더 좋다.”</p>
</blockquote>
<h3>3.1. 결론</h3>
<p><strong>Slice 자체가 offset 기반이라는 말은 반만 맞다.</strong></p>
<p>Slice는 “페이징 결과 형태”일 뿐이며,</p>
<p>실제로 offset 기반인지 keyset 기반인지는 <strong>쿼리가 결정</strong>한다.</p>
<p>즉,</p>
<ul>
<li>
<p><code>PageRequest.of(page, size)</code> 형태로 page가 증가하면</p>
<p>→ offset 기반이 맞다.</p>
</li>
<li>
<p>하지만 커서 기반이라면</p>
<p><code>PageRequest.of(0, size)</code>로 항상 page를 0으로 고정하고</p>
<p><code>WHERE modifiedAt &lt; :cursor</code> 같은 조건을 넣는다.</p>
<p>→ 이 경우 offset 비용은 발생하지 않는다.</p>
</li>
</ul>
<h3>3.2. 핵심 포인트</h3>
<ul>
<li>Slice는 내부적으로 <strong>hasNext 판단을 위해 size+1 조회</strong>를 한다.</li>
<li>하지만 offset 탐색 비용은 “page가 증가할 때”만 발생한다.</li>
<li>커서 기반 구현에서는 page를 0으로 고정하므로 offset 비용이 없다.</li>
</ul>
<hr>

<h2>4. hasNext 처리 방식 정리 (List vs Slice)</h2>
<h3>4.1. List로 반환할 때</h3>
<ul>
<li>서비스에서 <code>size+1</code>을 직접 조회해야 한다.</li>
<li>서비스에서 <code>hasNext</code> 계산 및 잘라내기 로직이 필요하다.</li>
</ul>
<p>장점:</p>
<ul>
<li>
<p>구현이 단순하고 명확함</p>
<p>단점:</p>
</li>
<li>
<p>서비스 코드에 페이징 잡일이 섞인다.</p>
</li>
</ul>
<hr>
<h3>4.2. Slice로 반환할 때</h3>
<ul>
<li>Spring Data가 내부적으로 <code>size+1</code> 조회를 수행한다.</li>
<li>서비스는 <code>slice.hasNext()</code>만 호출하면 된다.</li>
</ul>
<p>장점:</p>
<ul>
<li>
<p>서비스 코드가 깔끔해진다.</p>
<p>단점:</p>
</li>
<li>
<p>DB에서 size+1 조회 자체가 없어지는 건 아니다.</p>
<p>(성능은 거의 동일)</p>
</li>
</ul>
<hr>

<h2>5. 종합 비교표</h2>

항목 | 1번: 서브쿼리 단일 쿼리 | 2번: 2단계 로직 분리
-- | -- | --
DB 호출 횟수 | 1회 | 2회
lastId 검증 | 어려움/애매함 | 매우 명확
쿼리 복잡도 | 높음 (서브쿼리) | 낮음 (단순 비교)
인덱스 최적화 | DB 옵티마이저에 의존 | 설계가 명확함
확장성(조건 추가) | 쿼리 복잡도 급증 가능 | 단계별로 수정 쉬움
서비스 코드 깔끔함 | 보통 (hasNext 직접 처리) | Slice 쓰면 매우 깔끔
성능 안정성 | 상황에 따라 편차 가능 | 인덱스 있으면 안정적


<hr>

<h2>6. 결론</h2>

<li>
<p>둘 다 “커서 기반 keyset pagination”이므로</p>
<p>offset pagination보다 훨씬 좋은 선택이다.</p>
</li>
<li>
<p>성능은 결국 <strong>인덱스 설계</strong>가 좌우한다.</p>
</li>
</ul>

<hr>
<h2>7. 팀 커뮤니케이션용 결론 (요약)</h2>
<ul>
<li>2번 방식도 커서 기반이며, Slice가 offset 기반이라는 리뷰는 “page 증가를 쓰는 경우에만” 해당한다.</li>
<li>2번 방식은 page를 항상 0으로 고정하므로 offset 비용이 발생하지 않는다.</li>
<li>1번 방식은 쿼리 1번이라는 장점이 있지만, 서브쿼리 최적화/lastId 검증 측면에서 리스크가 있다.</li>
<li>hasNext 계산은 Slice로 반환하면 서비스에서 제거할 수 있다(성능은 동일).</li>
</ul>
<!-- notionvc: 7d82e965-dfad-414d-9c84-963b852f2414 -->