# 🤔 실시간 첨삭 기능, 어떻게 구현할 것인가? (데이터 구조부터 OT 알고리즘까지)

Narratix 서비스의 핵심은 하나의 자기소개서를 두고 작성자(Writer)와 첨삭자(Reviewer)가 실시간으로 피드백을 주고받는 기능입니다. 이를 구현하기 위해 설계 단계부터 치열하게 고민했던 아키텍처 결정 과정과 트레이드오프(Trade-off)를 공유하고자 합니다.

크게 두 가지 기술적 난제가 있었습니다. 
- **"첨삭 댓글의 위치를 어떻게 추적하고 동기화할 것인가?"** 
- **"충돌 없는 동시 편집을 어떻게 구현할 것인가?"** 

---
## 🔄 첫 번째 난제: 첨삭 댓글(Review)의 위치 추적 방식

일반적인 게시판의 댓글과 달리, 텍스트 에디터 기반의 실시간 첨삭은 본문이 수정됨에 따라 댓글이 가리키는 텍스트의 위치도 실시간으로 변해야 합니다. 이를 구현하기 위해 4가지 방식을 후보에 두고 검토했습니다.

### 1. 인덱스 (Index) 방식

가장 직관적으로 댓글이 시작하는 `startIdx`와 끝나는 `endIdx`를 DB에 저장하는 방식입니다.

- **장점:** 개념이 단순하고 초기 구현이 매우 쉽습니다.
    
- **단점:** 누군가 글의 맨 앞에 글자 하나만 추가해도, 그 뒤에 있는 **모든 댓글의 인덱스를 DB에서 통째로 업데이트(+1)** 해주어야 합니다. 잦은 수정이 일어나는 동시 편집 환경에서는 DB 부하가 극심해집니다.

### 2. Linked List 방식

인덱스 방식의 단점을 보완하기 위해, 절대적인 인덱스 대신 **"이전 댓글과의 거리(Offset)"**를 저장하는 방식입니다.

- **장점:** 글이 추가/수정되더라도 변경이 발생한 위치 바로 뒤에 있는 댓글 하나의 Offset만 수정하면 됩니다.
    
- **단점:** 클라이언트가 특정 텍스트에 칠해진 하이라이트(댓글)를 렌더링하려면 처음부터 끝까지 연결 리스트를 순회하며 인덱스를 계산해야 합니다. 또한, 중간에 통신 유실로 정합성이 하나라도 어긋나면 도미노처럼 뒤쪽의 모든 댓글 위치가 망가지는 치명적인 결함이 있습니다.

### 3. CRDT (Conflict-free Replicated Data Type) 방식

텍스트의 문자 하나하나마다 고유한 메타데이터(ID, 타임스탬프, 댓글 ID 등)를 부여하는 방식입니다. (예: 안**녕하세**요 $\rightarrow$ '녕, 하, 세' 노드에 각각 `reviewIdx=2` 부여)

- **장점:** 충돌 해결 정합성을 보장하기 가장 완벽하며, Y.js 등 검증된 라이브러리가 존재합니다.
    
- **단점:** **압도적인 저장 공간과 검색 비용**이 듭니다. 1,000자짜리 글 10,000개만 있어도 1,000만 개의 개별 노드가 생성됩니다. 1,000자인 글에 달린 댓글 생성을 위해 각 개별 노드를 조회할 때마다 막대한 시간복잡도($O(log M)$ 이상)가 발생하여 속도 저하가 우려되었습니다. 또한 백엔드가 Java/Spring 환경인데, 최적화된 라이브러리(Y.js)가 주로 JavaScript 생태계에 맞춰져 있어 운영 복잡도도 증가합니다. JavaScript를 사용해보지 않은 팀원들 상황에서 JavaScript 도입은 충분히 더 고려해봐야 할 문제라고 생각했습니다.

### 4. 댓글 마커 (Marker) 방식

본문 텍스트 안에 직접 태그 형태의 마커를 삽입하여 위치를 저장하는 방식입니다. (예: `[r:10]안녕하세요[/r]`)

- **장점:** 댓글의 위치 정보가 텍스트 자체에 내장되므로, **서버가 별도로 인덱스를 계산하거나 관리할 필요가 없어 성능상 압도적으로 유리**합니다.
    
- **단점:** 클라이언트(에디터) 측에서 유저가 백스페이스 등으로 마커 문법 자체를 훼손하지 않도록 방어 로직을 꼼꼼히 짜야 합니다. 또한, "댓글을 다는 행위 = 본문 텍스트를 수정하는 행위"가 되므로 **본격적인 동시 편집 알고리즘의 도입이 강제**됩니다.

### ✅ 최종 선택: 댓글 마커 방식

서버의 상태 관리 부담을 최소화하고 텍스트와 댓글 위치의 생명주기를 완벽하게 일치시키기 위해 **댓글 마커 방식**을 최종 채택했습니다.

### 📉 아쉬운 점과 리스크

- **리스크:** 유저의 비정상적인 입력으로 마커 포맷이 깨질 경우 정규식 파싱에 에러가 발생할 수 있어, 프론트엔드 단의 에디터 제어 난이도가 높아졌습니다.
    
- **포기한 부분:** 마커 삽입으로 인해 본문 데이터가 실시간으로 변경되므로, 이를 매끄럽게 처리할 **동시 편집 알고리즘**이라는 새로운 복잡성을 떠안게 되었습니다.

---
## 🔄 두 번째 난제: 동시 편집 관리 방식 (CRDT vs. OT)

댓글 마커 방식으로 인해 동시 편집 처리가 필수불가결해졌습니다. 분산 환경의 동시 편집을 해결하는 두 가지 거대한 산맥인 CRDT와 OT(Operational Transformation)를 비교했습니다.

### 1. CRDT 방식

(앞서 댓글 위치 추적 방식에서 살펴본 바와 같이) 데이터의 병합을 수학적으로 보장하는 방식입니다.

- 중앙 서버의 연산 개입 없이 클라이언트 간 병합이 가능하지만, 글자 단위의 메타데이터 관리로 인한 스토리지/메모리 부하와 Java 백엔드 환경에서의 인프라 구성 한계가 명확했습니다.

### 2. Operational Transformation (OT) 방식

클라이언트들이 전송한 변경 연산(Delta)을 중앙 서버가 시간 순서와 인덱스를 기준으로 변환하여 정합성을 맞추는 기법입니다. 구글 독스(Google Docs) 등에서 사용하는 전통적이고 강력한 방식입니다.

- **장점:** 문자열을 통째로 보내지 않고 변경된 연산(예: '3번 인덱스에 A 추가')만 주고받아 직관적입니다.
    
- **단점:** 모든 연산이 서버를 거쳐야 하므로 서버 부하가 높고, 레이턴시에 따라 클라이언트의 사용성이 떨어질 수 있습니다.

### ✅ 최종 선택: OT (Operational Transformation) 방식

Narratix의 도메인 특성이 이 결정을 뒷받침했습니다. 우리 서비스는 구글 독스처럼 수십 명이 접속하는 환경이 아니라, **하나의 자소서에 철저히 Writer 1명, Reviewer 1명만 접속하는 구조**입니다.

따라서 OT의 최대 단점인 '중앙 서버 병목 현상'이 우리 시스템에서는 유의미한 과부하로 이어지지 않을 것이라 판단했습니다. 반면, CRDT 도입으로 인해 발생할 거대한 텍스트 메타데이터 파싱 부하와 인프라적 이질감을 피하는 것이 훨씬 경제적이었습니다.

### 📉 아쉬운 점과 극복 과제

- **포기한 부분:** Y.js, Automerge 같은 CRDT 기반 라이브러리를 썼다면 클라이언트는 수신한 데이터만 던져주면 알아서 문서가 완성될 수 있었을 것입니다.
    
- **감수한 리스크:** OT 알고리즘(Delta 병합 및 index shift 로직)을 서버와 클라이언트 양측에서 직접 땀 흘려 구현하고 검증해야 하는 엔지니어링 비용을 감수하기로 했습니다. (결과적으로 이 과정에서 앞선 포스팅에서 다룬 'Delta 순서 꼬임과 디바운싱 처리' 같은 값진 트러블슈팅 경험을 얻을 수 있었습니다.)