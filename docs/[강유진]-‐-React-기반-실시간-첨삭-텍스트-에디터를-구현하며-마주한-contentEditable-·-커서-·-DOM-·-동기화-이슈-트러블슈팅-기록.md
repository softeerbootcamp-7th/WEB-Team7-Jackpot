## 들어가며

실시간 첨삭 기능이 포함된 텍스트 에디터를 구현하면서,
단순한 입력 처리보다 훨씬 많은 문제를 마주하게 되었습니다.

이 에디터는 다음과 같은 요구사항을 가지고 있었습니다.

* `contentEditable` 기반 텍스트 입력
* 첨삭(리뷰) 영역을 span으로 감싸 시각적으로 구분
* 실시간 소켓 동기화
* 커서 위치 유지
* 드래그 선택 + 첨삭 모달 표시
* Undo / Redo, 빠른 입력, IME 입력 안정성

이 글에서는 그 과정에서 실제로 겪었던 **대표적인 트러블슈팅 사례와 해결 과정**,
그리고 **의도적으로 해결하지 않기로 결정한 문제들**까지 함께 정리합니다.

---

## 1. 복사/붙여넣기 시 첨삭 영역이 늘어나는 문제

### 문제 상황

* 첨삭(span) 영역을 포함해 복사 → 붙여넣기 시
* 첨삭 영역이 비정상적으로 확장됨

### 원인

브라우저 기본 copy 동작은

* **순수 텍스트가 아니라 HTML 구조 전체**를 복사
* zero width space(`\u200B`)까지 함께 포함

### 해결

* copy 시 zero width space 제거
* **HTML이 아닌 순수 텍스트만 복사**

```text
브라우저 기본 동작 차단 + 우리가 정의한 텍스트만 clipboard에 저장
```

---

## 2. 붙여넣기 후 startIndex / endIndex가 0으로 계산되는 버그

### 문제 시나리오

텍스트가 `"ABCDE"`일 때

1. Ctrl + A → 복사
2. 맨 뒤 클릭 → 커서 위치 5
3. 붙여넣기 → `"ABCDEABCDE"`
4. 서버로 전송되는 patch의 start / end index가 **0**

### 근본 원인

`sendTextPatch` 내부에서 `getCaretPosition()`을 **다시 호출**하고 있었음.

하지만 호출 순서는

```
sendTextPatch
 → updateText
   → handleTextChange
```

즉, **React 상태가 아직 반영되지 않은 DOM 기준**에서
커서 위치를 다시 계산하고 있었고,
이미 계산해 둔 `caretOffsetRef.current` 값이 무시되고 있었습니다.

### 해결

* `sendTextPatch`에서 `getCaretPosition()` 재호출 제거
* **항상 `caretOffsetRef.current`를 신뢰하도록 수정**

이 ref는 “작업 직후의 커서 위치”를 각 경로에서 미리 업데이트하도록 보장되어 있음.

---

## 3. 텍스트 변경 시 첨삭 모달 위치가 따라오지 않는 문제

### 문제 상황

* 텍스트 변경 후
* 첨삭 모달이 이전 위치에 고정되거나 사라짐

### 원인

* `updateSelectionForTextChange`는 `range`만 업데이트
* `modalTop / modalLeft`는 그대로 유지
* 드래그 모달은 최초 계산 이후 **재계산되지 않음**

### 해결

`useTextSelection` 내부에 `useLayoutEffect` 추가

```text
TEXT_UPDATE 수신
 → selection.range 업데이트
 → React 리렌더
 → useLayoutEffect (페인트 전 동기 실행)
   → DOM 기반으로 modal 위치 재계산
```

### 효과

1. **성능 개선**: 한 프레임 늦게 따라오던 문제 해결
2. **드래그 모달 안정화**: 텍스트 이동 시에도 정확히 따라옴

---

## 4. TEXT_REPLACE_ALL 이후 커서가 0으로 이동하는 문제

### 문제 상황

* TEXT_REPLACE_ALL 이벤트 발생 후
* 커서가 맨 앞으로 이동

### 원인

* DOM 교체 과정에서 브라우저가 `selectionchange` 이벤트 발생
* 이때 커서 위치가 **0으로 초기화**
* 해당 값을 커서 추적 로직이 덮어써버리는 Race Condition 발생

### 대응 전략

* 불안정한 `selectionchange` 이벤트 의존 제거
* **사용자 명시적 액션(키보드, 마우스)에서만 커서 추적**
* PageUp / PageDown 키도 추적 대상에 포함

> 완전한 해결은 아니지만,
> 빠른 입력 상황에서도 커서 안정성이 크게 개선됨

---

## 5. 드래그 후 입력 시 removeChild 에러 발생

### 문제 상황

* 첨삭(span) 영역을 포함해 드래그
* 다른 문자 입력
* `removeChild` 에러 발생

### 원인

* 브라우저가 내부 span을 직접 제거
* React가 **이미 제거된 DOM 노드**를 다시 제거하려다 충돌

### 해결

* 브라우저의 기본 DOM 삭제 동작을 차단
* **모든 삭제/변경을 상태 기반으로 직접 처리**

또한:

* 첨삭 삭제 시 TEXT_REPLACE_ALL 발생
* IME 입력이 composition 상태로 남아 입력이 날아가는 문제 발생
* 이에 대한 복구 로직 추가

---

## 6. 첨삭 내부 드래그 제약 (미해결)

### 상황

* 첨삭 영역은 `contentEditable: false`
* 결과적으로:

  * 전부 드래그하거나
  * 아예 드래그하지 않거나
  * 부분 선택 불가

### 결정

* 구조적 한계로 판단
* UX 타협 후 **해결하지 않기로 결정**

> 모든 문제를 기술적으로 해결하는 것이 항상 최선은 아니라고 판단

---

## 7. 빠른 입력 시 index 계산 이상

### 원인

* 빠른 입력 중 TEXT_REPLACE_ALL 빈번 발생
* 인덱스 계산 꼬임

### 해결

* **debounce 적용** (ISSUE 8과 함께 해결)

---

## 8-1. 실시간 소켓 이벤트 누락 문제

### 문제

* 빠른 입력 시

  * 소켓 이벤트 누락
  * 순서 뒤바뀜

### 고민

* throttle → IME 입력 깨짐 가능성
* debounce → 실시간성 저하

### 결론

* debounce **300ms**
* 실제 사용 테스트 기준 가장 자연스러움

---

## 8-2. debounce 이후 첨삭만 삭제되는 문제

### 원인

* delete 시 API 요청이 텍스트 반영보다 먼저 전송

### 해결

* 소켓 전송 함수에 `force` 옵션 추가
* **삭제 관련 이벤트는 즉시 전송**

---

## 9. 저장하기 API가 가끔 동작하지 않는 문제

### 원인

* `isSavingRef.current = true` 이후
* 유효성 검사 실패로 early return
* 다시 false로 초기화되지 않음

### 해결

* `isSavingRef.current = true` 설정 시점을

  * **실제 API 요청 직전으로 이동**

---

## 10. 저장 후 탭 이동 시 이전 결과가 보이는 문제

### 원인

* React Query 캐시 무효화 key 불일치

### 해결

* `invalidateQueries`의 `queryKey`를

  * `useQnAList`와 동일하게 맞춤

---

## 11. 조건부 훅 호출 에러

* 조건부로 hook 호출되던 코드 수정
* 호출 순서 고정

---

## 12. 첨삭 영역 간헐적 이상 동작 (미해결)

* 내부 index로 입력
* 태그 일부 소실
* 시간 부족으로 원인 완전 규명 못함

---

## 마무리

이번 실시간 첨삭 에디터 구현은
단순히 기능을 붙이는 작업이 아니라,

> **브라우저 DOM, React 상태, selection, IME 입력,
> 그리고 실시간 동기화가 어떻게 충돌하는지를 직접 체험한 과정**

이었습니다.

특히 느낀 점은

* `contentEditable + React`는 **브라우저 기본 동작을 신뢰하면 안 된다**
* 커서, selection, DOM 변경은 **상태 중심으로 통제**해야 예측 가능하다
* 모든 문제를 “완벽히 해결”할 필요는 없고,
  **명확한 근거를 가진 포기 또한 하나의 설계 결정**이다

라는 점이었습니다.
