# 🤔 [고민한 주제]
**복잡한 뷰(View) 전환 환경에서 네비게이션 상태의 응집도 향상 및 상태 전이(State Transition) 캡슐화**

## 📝 고민 배경
- **왜 이 고민을 하게 되었는가?**
  검색 결과 화면 안에서 '폴더 선택 -> 리스트 확인 -> 문항 상세 보기 -> 뒤로 가기' 등 뎁스(Depth)가 깊은 네비게이션 이동이 빈번하게 일어납니다. 초기에는 이를 컴포넌트 내부에서 여러 개의 `useState`로 흩어놓고 관리하다 보니, 상태 업데이트 타이밍이 어긋나거나 특정 액션(예: 폴더 리스트에서 뒤로 가기) 시 다른 상태가 제대로 초기화되지 않는 상태 꼬임 버그가 발생했습니다.
- **전제 조건:**
  - 사용자의 네비게이션 흐름(검색 결과 ↔ 폴더 ↔ 문항 상세)에 따라 UI가 정확하고 예측 가능하게 전환되어야 합니다.
  - 특정 액션이 발생했을 때 연관된 상태들이 한 번의 렌더링 사이클 내에서 동기화되어야 합니다 (예: 폴더를 선택하면 이전에 선택된 문항 상태는 반드시 초기화되어야 함).
- **제약 사항:**
  - 뷰 컴포넌트는 UI 렌더링에만 집중해야 하며, 복잡한 상태 변경 비즈니스 로직을 컴포넌트 내부에 노출시키면 안 됩니다.

## 🔄 고려한 선택지

### 선택지 1: 컴포넌트 내 개별 `useState` 사용
- **개념:** `selectedLibrary`, `selectedItem` 등 개별 상태를 컴포넌트 안에서 각각의 `useState`로 선언하고 관리하는 방식.
- **장점:** 초기에 가장 빠르게 작성할 수 있는 익숙한 패턴입니다.
- **단점:** 연관된 상태들이 파편화되어 있어, 상태 변경 시 동기화를 놓칠 위험이 매우 큽니다. (예: 폴더 진입 시 `setSelectedItem(null)`을 깜빡하면 이전 문항이 그대로 보이는 버그 발생)

### 선택지 2: 전역 상태 관리 라이브러리 (Zustand 등) 도입
- **개념:** 네비게이션 뷰 전환 상태를 전역 스토어에 위임하는 방식.
- **장점:** 컴포넌트 트리 어디서든 쉽게 접근 및 제어가 가능합니다.
- **단점:** 이 네비게이션 상태는 특정 사이드바/검색 결과 뷰 안에서만 유효한 '로컬 도메인 상태'입니다. 이를 전역으로 빼는 것은 불필요한 의존성을 만들고, 오히려 초기화(Reset) 관리를 어렵게 만듭니다.

### 선택지 3: 단일 객체 기반의 Custom Hook (`useLibraryNavigation`) 캡슐화 (최종 방안)
- **개념:** 연관된 네비게이션 상태를 단일 객체(`NavigationState`)로 그룹화하고, 이를 변경하는 로직(Action)들을 하나의 훅에 캡슐화하여 노출하는 방식.
- **장점:** 하나의 상태 객체로 관리되므로, `setState` 호출 시 상태의 무결성을 보장할 수 있습니다 (Atomic Update). 컴포넌트는 `selectLibrary` 같은 직관적인 인터페이스만 호출하면 되어 비즈니스 로직과 UI가 완벽히 분리됩니다.
- **단점:** 새로운 액션이 추가될 때마다 훅 내부의 상태 전이 로직을 수정해야 합니다.

## ⚖️ 비교 정리

| 항목 | 선택지 1 (개별 useState) | 선택지 2 (전역 상태 도입) | 선택지 3 (단일 객체 Custom Hook) |
|------|--------------------------|---------------------------|----------------------------------|
| **코드 응집도** | 최악 (로직이 UI에 산재됨) | 낮음 (뷰 상태가 전역으로 퍼짐) | **최상 (관련 상태와 로직이 한곳에 집중)** |
| **상태 무결성** | 나쁨 (개발자 실수 유발) | 보통 | **최상 (정의된 메서드로만 상태 변경 가능)** |
| **유지보수** | 나쁨 (추적 어려움) | 보통 | **최상 (상태 전이 흐름 파악 용이)** |

## ✅ 최종 선택
- **선택한 방안:** 선택지 3 (단일 객체 기반의 Custom Hook `useLibraryNavigation` 캡슐화)
- **선택 이유:** 리액트가 지향하는 '연관된 상태의 그룹화(Group related state)' 원칙에 가장 잘 부합하기 때문입니다. 상태와 비즈니스 로직을 `useLibraryNavigation` 내부로 캡슐화함으로써, 컴포넌트는 '무엇(What)'을 그릴지만 고민하고 '어떻게(How)' 상태가 변하는지는 훅에 온전히 위임할 수 있게 되었습니다. 

```typescript
// 구현된 useLibraryNavigation의 핵심 구조
export const useNavigation = () => {
  const [state, setState] = useState<NavigationState>({
    selectedItem: null,
    selectedLibrary: null,
  });

  // 상태 전이(Transition) 메서드들을 명확히 정의
  const selectLibrary = (libraryName: string) => {
    // 폴더 선택 시 문항 초기화를 보장
    setState({ selectedItem: null, selectedLibrary: libraryName });
  };
  // ... 생략 ...
};
```

## 📉 아쉬운 점
포기한 부분: 상태가 객체 형태이므로, 하위의 뎁스가 더 깊어지거나 구조가 복잡해지면 일반 useState 객체 업데이트(...prev) 방식이 다소 번거로워질 수 있습니다.

리스크: 향후 뒤로 가기 기록(History)까지 관리해야 하는 요구사항이 생긴다면 현재의 구조만으로는 한계가 있을 수 있습니다.

## 🔮 이후 개선 방향
추후 다시 고려할 사항: 만약 네비게이션 뎁스가 현재보다 훨씬 깊어지거나(예: 폴더 > 하위 폴더 > 문항), 이전 경로들을 스택(Stack)처럼 쌓아둬야 한다면, 단순한 useState 객체를 넘어 useReducer를 도입하여 복잡한 상태 전이(State Machine)를 더욱 견고하게 다루는 방향으로 개선해 볼 수 있습니다.