# 🗓️ [구현기] React로 커스텀 캘린더 바닥부터 만들기
관련 [커밋](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/commit/2e5ac12c6e68e6e33d4d5033492c39b4124d0f8d#diff-20c87df0bcba8408ced94c534a81d069aab99fa0b6042f09864faa02acf3db41)입니다

> [🤔 커스텀 캘린더 아키텍처 설계 및 고민 과정 보러가기](https://github.com/softeerbootcamp-7th/WEB-Team7-Jackpot/wiki/%5B%EB%B0%95%EC%86%8C%EB%AF%BC%5D-%E2%80%90-%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%84%B1%EA%B3%BC-%EC%9C%A0%EC%A7%80%EB%B3%B4%EC%88%98%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%BA%98%EB%A6%B0%EB%8D%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%84%A4%EA%B3%84)

채용 공고 마감일과 개인 일정을 한눈에 관리해야 하는 캘린더 뷰를 구현하면서, 무거운 외부 라이브러리 대신 직접 캘린더를 구축하기로 결정했습니다. FSD(Feature-Sliced Design) Lite 아키텍처를 기반으로, 어떻게 로직과 UI를 분리하며 구현했는지 단계별로 정리했습니다.

---

## 🛠️ Step 1. Domain Layer: 순수 로직 분리 (리액트 없는 세상)
가장 먼저 한 일은 **"리액트가 없어도 캘린더 날짜를 계산할 수 있는가?"**에 대한 답을 코드로 적는 것이었습니다. 날짜 계산의 불변성을 보장하기 위해 `date-fns`를 활용하여 순수 유틸리티 함수를 작성했습니다.

`src/shared/utils/dateUtils.ts`
```typescript
import { startOfMonth, endOfMonth, startOfWeek, endOfWeek, eachDayOfInterval } from 'date-fns';

// 시작일과 종료일 사이의 모든 날짜 배열 반환
export const generateDateGrid = (start: Date, end: Date) => 
  eachDayOfInterval({ start, end });

// 특정 날짜가 속한 달의 전체 달력 범위(이전 달/다음 달 며칠 포함) 계산
export const getMonthRange = (date: Date) => {
  const monthStart = startOfMonth(date);
  const monthEnd = endOfMonth(date);
  return { 
    startDate: startOfWeek(monthStart), 
    endDate: endOfWeek(monthEnd) 
  };
};
```

## ⚙️ Step 2. Shared Hook: 날짜 그리드 생성 로직 분리
​이후 3주 뷰, 주간 뷰 등 캘린더의 형태가 확장될 수 있으므로, 날짜 배열을 만들어내는 로직을 공통 훅으로 분리했습니다. useMemo를 사용해 시작일과 종료일이 같으면 배열을 재생성하지 않도록 최적화했습니다.
​`src/shared/hooks/useDataGrid.ts`
```
import { useMemo } from 'react';
import { generateDateGrid } from '../utils/dateUtils';

export const useDataGrid = (startDate: Date, endDate: Date) => {
  const days = useMemo(() => {
    return generateDateGrid(startDate, endDate);
  }, [startDate, endDate]);

  return days;
};

```

## 🧠 Step 3. Application Layer: 캘린더의 '뇌' 만들기
​이제 UI에 필요한 상태(현재 달, 선택된 날짜)와 행위(이전/다음 달 이동), 그리고 판단 로직(오늘인가? 이번 달인가?)을 제공하는 비즈니스 로직 훅을 작성했습니다. UI 컴포넌트는 아무런 계산도 하지 않도록 헬퍼(helpers) 함수를 내려주는 것이 핵심입니다.

`src/features/calendar/hooks/useCalendar.ts`
```
import { useState, useMemo, useCallback } from 'react';
import { useDataGrid } from '@/shared/hooks/useDataGrid';
import { getMonthRange, isSameDay, addMonths, subMonths } from '@/shared/utils/dateUtils';

export const useCalendar = () => {
  const [currentDate, setCurrentDate] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState(new Date());

  const { startDate, endDate } = useMemo(() => getMonthRange(currentDate), [currentDate]);
  const days = useDataGrid(startDate, endDate);

  // Handlers (useCallback으로 불필요한 리렌더링 방지)
  const handlers = {
    handleNextMonth: useCallback(() => setCurrentDate(prev => addMonths(prev, 1)), []),
    handlePrevMonth: useCallback(() => setCurrentDate(prev => subMonths(prev, 1)), []),
    handleDateClick: useCallback((date: Date) => setSelectedDate(date), []),
  };

  // Helpers (UI를 멍청하게 만드는 핵심)
  const helpers = {
    isSelected: (date: Date) => isSameDay(date, selectedDate),
    isCurrentMonth: (date: Date) => date.getMonth() === currentDate.getMonth(),
  };

  return { currentDate, selectedDate, days, handlers, helpers };
};

```

## 🎨 Step 4. Presentation Layer: 바보 컴포넌트(Dumb Component) 조립
​마지막으로 UI 컴포넌트입니다. CalendarDay는 자신이 무슨 요일인지, 오늘이 며칠인지 계산하지 않습니다. 오직 props로 넘어온 boolean 값(isCurrentMonth, isSelected)에 따라 Tailwind CSS 클래스만 변경합니다. 추후 API를 연결해 채용 공고 마감일(hasDeadline) 데이터가 추가되더라도 이 컴포넌트는 쉽게 확장됩니다.

`​src/features/calendar/components/CalendarDay.tsx
`
```
import { format } from 'date-fns';

interface CalendarDayProps {
  date: Date;
  isCurrentMonth: boolean; 
  isSelected: boolean;     
  onClick: (date: Date) => void;
}

export const CalendarDay = ({ date, isCurrentMonth, isSelected, onClick }: CalendarDayProps) => {
  return (
    <button
      onClick={() => onClick(date)}
      className={`
        flex items-center justify-center w-10 h-10 rounded-full transition-colors
        ${!isCurrentMonth ? 'text-gray-300' : 'text-gray-900'} 
        ${isSelected ? 'bg-blue-600 text-white font-bold' : 'hover:bg-gray-100'}
      `}
    >
      {format(date, 'd')} 
    </button>
  );
};

```

## 💡 구현 회고
​처음에는 단일 컴포넌트에 모든 코드를 만들고 나서 분리할까 싶었지만, 그래도 한 번 해보자라는 마음가짐으로 Layered Architecture에 맞춰 역할을 분리했습니다. 결과적으로 useCalendar 훅에서 상태와 비즈니스 로직을 완벽히 제어할 수 있게 되었고, 팀원들과 협업할 때 "날짜 로직은 utils에, 렌더링 에러는 ui에 있다"는 명확한 기준을 공유할 수 있어 유지보수가 훨씬 수월해졌습니다. 따라서 이후에 date-fns를 직접 구현한 날짜 유틸 함수로 변환할 수 있었습니다.