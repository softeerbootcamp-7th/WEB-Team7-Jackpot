# 🐞 SSE 기반 실시간 알림이 연속된 새로고침에서 재연결이 발생하는 문제점 (SSE 연결 이야기 2편)

## 요약
- 증상: 연속된 새로고침을 하면 새롭게 연결을 시도하고 서버에 기존 요청이 비정상적으로 누적되어 설정된 최대 연결 수(5개)를 초과하여 400 에러가 발생함

## 📌 문제 상황
- 구현 정보:
  - 실시간 통신 방식 중 SSE를 이용하여 실시간 알림을 구현
  - 다중 탭 환경에서 서버 리소스 낭비를 막고자 SharedWorker를 활용하여 단일 SSE 연결을 여러 탭이 공유하는 아키텍처 적용 (Vite 환경)
- 문제 상황:
  - 단일 탭 상태에서 새로고침을 연타하면 SSE 연결 요청이 계속 서버로 보내짐
  - 브라우저 단에서는 연결이 끊겼다고 판단하여 새 연결을 시도하지만 서버에서는 이전 SSE 연결(좀비 커넥션)이 살아있다고 판단함
  - 유저당 최대 연결 개수(5개)에 도달 시 서버에서 400 Bad Request 에러를 반환함
  - 연결 슬롯 중 한 자리가 비워질 때까지 클라이언트가 지수 백오프 + Jitter 로 재연결 요청을 반복하다가 성공함

## 🔍 원인 분석
- 처음 의심한 원인: SSE 연결을 재사용하지 못해서 새로고침하면 새롭게 연결을 보내는 것으로 의심
- 실제 원인:
  - Shared Worker는 자신을 참조하는 탭(Port)이 1개라도 있어야 생존하지만 단일 탭에서 새로고침을 누르는 순간 탭이 0개가 되고 브라우저는 메모리 확보를 위해 Worker 프로세스를 즉각 강제 종료시켜버린다.
- 원인 파악 과정:
  - Shared Worker를 도입하고 단일 탭에서 새로고침을 누르는 순간 탭이 0개가 되고 브라우저는 메모리 확보를 위해 Worker 프로세스를 즉각 강제 종료시켜버린다.
  - `chrome://inspect/#workers`에서 단일 탭 새로고침 시 Worker 인스턴스 자체가 사라졌다가 새롭게 생성되는 것을 확인하고 Shared Worker 방식의 한계라고 깨달음

## 🛠 시도 방법
1. Shared Worker 도입
  - Shared Worker를 도입하여 여러 탭이 동일한 SSE를 공유
2. 지수 백오프 알고리즘 & Jitter 도입
  - 3초마다 연결을 재시도 -> 지수 백오프 방식으로 연결을 재시도하여 서버 부하 경감, 트래픽 집중을 분산시키기 위해 랜덤 수치를 곱하는 Jitter 개념 도입
3. 서버의 heartbeat 주기 단축
  - 현재로서는 효과가 가장 좋은 시도 방법이었고 연결 가능한 자리가 만들어지는 시간이 굉장히 짧아졌다.

## 추가적으로 고민해볼 내용
- 단일 탭에서 여러 번의 새로고침을 누르면 좀비 커넥션이 남아있어서 연결 초과가 되는 문제는 해결하지 못했지만 해결 방안을 구상해봄
  1. 오버 엔지니어링이지만 Service Worker를 도입하고 flush를 잘 해주는 방식으로 단일 탭 새로고침에 대한 방어를 도전해보고 싶음
  2. 별도의 disconnect api나 서버에서 덮어쓰기 방식을 도입하면서 함께 수정해보고 싶음